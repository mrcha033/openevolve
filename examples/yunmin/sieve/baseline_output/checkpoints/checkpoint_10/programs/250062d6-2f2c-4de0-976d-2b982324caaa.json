{"id": "250062d6-2f2c-4de0-976d-2b982324caaa", "code": "#include <algorithm>\n#include <chrono>\n#include <cmath>\n#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n\n// Reference: pi(10^7) = 664579\nstatic int ReferencePrimeCount(int limit) {\n    std::vector<bool> is_prime(limit + 1, true);\n    is_prime[0] = is_prime[1] = false;\n    for (int i = 2; (long long)i * i <= limit; ++i) {\n        if (is_prime[i]) {\n            for (int j = i * i; j <= limit; j += i)\n                is_prime[j] = false;\n        }\n    }\n    int count = 0;\n    for (int i = 2; i <= limit; ++i)\n        if (is_prime[i]) ++count;\n    return count;\n}\n\n// EVOLVE-BLOCK-START\n\nstatic int CountPrimes(int limit) {\n    if (limit < 2) return 0;\n    \n    // Use bool vector for better cache locality and bit operations\n    std::vector<bool> is_prime(limit + 1, true);\n    is_prime[0] = is_prime[1] = false;\n    \n    // Only check odd numbers after 2\n    const int sqrt_limit = static_cast<int>(std::sqrt(limit)) + 1;\n    \n    // Handle 2 separately\n    for (int j = 4; j <= limit; j += 2) {\n        is_prime[j] = false;\n    }\n    \n    // Process odd numbers only\n    for (int i = 3; i < sqrt_limit; i += 2) {\n        if (is_prime[i]) {\n            // Start marking from i*i, and increment by 2*i to skip even multiples\n            for (int j = i * i; j <= limit; j += 2 * i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n    \n    // Count primes (skip even numbers except 2)\n    int count = 1; // Account for 2\n    for (int i = 3; i <= limit; i += 2) {\n        count += is_prime[i];\n    }\n    \n    return count;\n}\n\n// EVOLVE-BLOCK-END\n\nstatic void WriteJson(const std::string &path, const std::string &payload) {\n    if (path.empty()) { std::cout << payload << std::endl; return; }\n    std::ofstream out(path.c_str(), std::ios::binary);\n    out << payload;\n}\n\nint main(int argc, char **argv) {\n    std::string json_path;\n    int limit = 10000000;  // 10^7\n    int rounds = 10;\n\n    for (int i = 1; i < argc; ++i) {\n        std::string arg = argv[i];\n        if (arg == \"--json\" && i + 1 < argc) json_path = argv[++i];\n        else if (arg == \"--limit\" && i + 1 < argc) limit = std::atoi(argv[++i]);\n        else if (arg == \"--rounds\" && i + 1 < argc) rounds = std::atoi(argv[++i]);\n    }\n\n    // Correctness check\n    int ref_count = ReferencePrimeCount(limit);\n    int got_count = CountPrimes(limit);\n    if (ref_count != got_count) {\n        std::cerr << \"prime count mismatch: expected \" << ref_count\n                  << \" got \" << got_count << std::endl;\n        return 2;\n    }\n\n    // Benchmark\n    std::vector<double> latencies;\n    latencies.reserve(rounds);\n    double total_time = 0.0;\n\n    for (int r = 0; r < rounds; ++r) {\n        auto t0 = std::chrono::high_resolution_clock::now();\n        CountPrimes(limit);\n        auto t1 = std::chrono::high_resolution_clock::now();\n        double dt = std::chrono::duration<double>(t1 - t0).count();\n        latencies.push_back(dt);\n        total_time += dt;\n    }\n\n    double ops_per_sec = rounds / total_time;\n    std::sort(latencies.begin(), latencies.end());\n    double p99 = latencies.empty() ? 0.0\n        : latencies[(size_t)(0.99 * (latencies.size() - 1))];\n\n    std::ostringstream os;\n    os.setf(std::ios::fixed);\n    os.precision(6);\n    os << \"{\\\"ops_per_sec\\\":\" << ops_per_sec\n       << \",\\\"p99_latency_us\\\":\" << (p99 * 1e6)\n       << \",\\\"prime_count\\\":\" << got_count << \"}\";\n    WriteJson(json_path, os.str());\n    return 0;\n}", "changes_description": null, "language": "cpp", "parent_id": "194bae06-3db5-4d05-a1fd-ce175cadd8c9", "generation": 2, "timestamp": 1770563109.840756, "iteration_found": 5, "metrics": {"combined_score": 1.2918, "ops_per_sec": 39.902984, "p99_latency_us": 25073.346, "bcoz_max_speedup": 5.0, "bperf_offcpu_ratio": 0.02}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"combined_score": 1.3103, "ops_per_sec": 40.480264, "p99_latency_us": 24732.626, "bcoz_max_speedup": 5.0, "bperf_offcpu_ratio": 0.02}, "island": 0}, "prompts": {"full_rewrite_user": {"system": "You are a C++ performance optimization expert.\nOptimize the prime-counting sieve inside the EVOLVE-BLOCK.\n\nRequirements:\n- Only modify code inside the EVOLVE-BLOCK.\n- Keep the function signature: int CountPrimes(int limit)\n- Must return the exact count of primes <= limit.\n- Use only the C++ standard library. No external dependencies.\n- Do not add top-level side effects or debug printing.\n\nMake the sieve as fast as possible.\n", "user": "# Current Program Information\n- Fitness: 1.3103\n- Feature coordinates: ops_per_sec=40.48, p99_latency_us=24732.63\n- Focus areas: - Fitness improved: 1.0455 \u2192 1.3103\n- Exploring ops_per_sec=40.48, p99_latency_us=24732.63 region of solution space\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Metrics: combined_score: 1.0455, ops_per_sec: 32.2120, p99_latency_us: 30776.6090, bcoz_max_speedup: 5.0000, bperf_offcpu_ratio: 0.0200\n- Outcome: Improvement in all metrics\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: combined_score: 1.3103, ops_per_sec: 40.4803, p99_latency_us: 24732.6260, bcoz_max_speedup: 5.0000, bperf_offcpu_ratio: 0.0200\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: combined_score: 1.3104, ops_per_sec: 40.4800, p99_latency_us: 24723.2900, bcoz_max_speedup: 5.0000, bperf_offcpu_ratio: 0.0200\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 1.3104)\n```cpp\n#include <algorithm>\n#include <chrono>\n#include <cmath>\n#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n\n// Reference: pi(10^7) = 664579\nstatic int ReferencePrimeCount(int limit) {\n    std::vector<bool> is_prime(limit + 1, true);\n    is_prime[0] = is_prime[1] = false;\n    for (int i = 2; (long long)i * i <= limit; ++i) {\n        if (is_prime[i]) {\n            for (int j = i * i; j <= limit; j += i)\n                is_prime[j] = false;\n        }\n    }\n    int count = 0;\n    for (int i = 2; i <= limit; ++i)\n        if (is_prime[i]) ++count;\n    return count;\n}\n\n// EVOLVE-BLOCK-START\n\nstatic int CountPrimes(int limit) {\n    if (limit < 2) return 0;\n    \n    // Use bool vector for better cache locality and bit operations\n    std::vector<bool> is_prime(limit + 1, true);\n    is_prime[0] = is_prime[1] = false;\n    \n    // Only check odd numbers after 2\n    const int sqrt_limit = static_cast<int>(std::sqrt(limit)) + 1;\n    \n    // Handle 2 separately\n    for (int j = 4; j <= limit; j += 2) {\n        is_prime[j] = false;\n    }\n    \n    // Process odd numbers only\n    for (int i = 3; i < sqrt_limit; i += 2) {\n        if (is_prime[i]) {\n            // Start marking from i*i, and increment by 2*i to skip even multiples\n            for (int j = i * i; j <= limit; j += 2 * i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n    \n    // Count primes (skip even numbers except 2)\n    int count = 1; // Account for 2\n    for (int i = 3; i <= limit; i += 2) {\n        count += is_prime[i];\n    }\n    \n    return count;\n}\n\n// EVOLVE-BLOCK-END\n\nstatic void WriteJson(const std::string &path, const std::string &payload) {\n    if (path.empty()) { std::cout << payload << std::endl; return; }\n    std::ofstream out(path.c_str(), std::ios::binary);\n    out << payload;\n}\n\nint main(int argc, char **argv) {\n    std::string json_path;\n    int limit = 10000000;  // 10^7\n    int rounds = 10;\n\n    for (int i = 1; i < argc; ++i) {\n        std::string arg = argv[i];\n        if (arg == \"--json\" && i + 1 < argc) json_path = argv[++i];\n        else if (arg == \"--limit\" && i + 1 < argc) limit = std::atoi(argv[++i]);\n        else if (arg == \"--rounds\" && i + 1 < argc) rounds = std::atoi(argv[++i]);\n    }\n\n    // Correctness check\n    int ref_count = ReferencePrimeCount(limit);\n    int got_count = CountPrimes(limit);\n    if (ref_count != got_count) {\n        std::cerr << \"prime count mismatch: expected \" << ref_count\n                  << \" got \" << got_count << std::endl;\n        return 2;\n    }\n\n    // Benchmark\n    std::vector<double> latencies;\n    latencies.reserve(rounds);\n    double total_time = 0.0;\n\n    for (int r = 0; r < rounds; ++r) {\n        auto t0 = std::chrono::high_resolution_clock::now();\n        CountPrimes(limit);\n        auto t1 = std::chrono::high_resolution_clock::now();\n        double dt = std::chrono::duration<double>(t1 - t0).count();\n        latencies.push_back(dt);\n        total_time += dt;\n    }\n\n    double ops_per_sec = rounds / total_time;\n    std::sort(latencies.begin(), latencies.end());\n    double p99 = latencies.empty() ? 0.0\n        : latencies[(size_t)(0.99 * (latencies.size() - 1))];\n\n    std::ostringstream os;\n    os.setf(std::ios::fixed);\n    os.precision(6);\n    os << \"{\\\"ops_per_sec\\\":\" << ops_per_sec\n       << \",\\\"p99_latency_us\\\":\" << (p99 * 1e6)\n       << \",\\\"prime_count\\\":\" << got_count << \"}\";\n    WriteJson(json_path, os.str());\n    return 0;\n}\n```\nKey features: Performs well on combined_score (1.3104), Performs well on ops_per_sec (40.4800), Performs well on p99_latency_us (24723.2900), Performs well on bcoz_max_speedup (5.0000), Performs well on bperf_offcpu_ratio (0.0200)\n\n### Program 2 (Score: 1.3103)\n```cpp\n#include <algorithm>\n#include <chrono>\n#include <cmath>\n#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n\n// Reference: pi(10^7) = 664579\nstatic int ReferencePrimeCount(int limit) {\n    std::vector<bool> is_prime(limit + 1, true);\n    is_prime[0] = is_prime[1] = false;\n    for (int i = 2; (long long)i * i <= limit; ++i) {\n        if (is_prime[i]) {\n            for (int j = i * i; j <= limit; j += i)\n                is_prime[j] = false;\n        }\n    }\n    int count = 0;\n    for (int i = 2; i <= limit; ++i)\n        if (is_prime[i]) ++count;\n    return count;\n}\n\n// EVOLVE-BLOCK-START\n\nstatic int CountPrimes(int limit) {\n    if (limit < 2) return 0;\n    \n    // Use bool vector for better cache locality and bit operations\n    std::vector<bool> is_prime(limit + 1, true);\n    is_prime[0] = is_prime[1] = false;\n    \n    // Only check odd numbers after 2\n    const int sqrt_limit = static_cast<int>(std::sqrt(limit)) + 1;\n    \n    // Handle 2 separately\n    for (int j = 4; j <= limit; j += 2) {\n        is_prime[j] = false;\n    }\n    \n    // Process odd numbers only\n    for (int i = 3; i < sqrt_limit; i += 2) {\n        if (is_prime[i]) {\n            // Start marking from i*i, and increment by 2*i to skip even multiples\n            for (int j = i * i; j <= limit; j += 2 * i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n    \n    // Count primes (skip even numbers except 2)\n    int count = 1; // Account for 2\n    for (int i = 3; i <= limit; i += 2) {\n        count += is_prime[i];\n    }\n    \n    return count;\n}\n\n// EVOLVE-BLOCK-END\n\nstatic void WriteJson(const std::string &path, const std::string &payload) {\n    if (path.empty()) { std::cout << payload << std::endl; return; }\n    std::ofstream out(path.c_str(), std::ios::binary);\n    out << payload;\n}\n\nint main(int argc, char **argv) {\n    std::string json_path;\n    int limit = 10000000;  // 10^7\n    int rounds = 10;\n\n    for (int i = 1; i < argc; ++i) {\n        std::string arg = argv[i];\n        if (arg == \"--json\" && i + 1 < argc) json_path = argv[++i];\n        else if (arg == \"--limit\" && i + 1 < argc) limit = std::atoi(argv[++i]);\n        else if (arg == \"--rounds\" && i + 1 < argc) rounds = std::atoi(argv[++i]);\n    }\n\n    // Correctness check\n    int ref_count = ReferencePrimeCount(limit);\n    int got_count = CountPrimes(limit);\n    if (ref_count != got_count) {\n        std::cerr << \"prime count mismatch: expected \" << ref_count\n                  << \" got \" << got_count << std::endl;\n        return 2;\n    }\n\n    // Benchmark\n    std::vector<double> latencies;\n    latencies.reserve(rounds);\n    double total_time = 0.0;\n\n    for (int r = 0; r < rounds; ++r) {\n        auto t0 = std::chrono::high_resolution_clock::now();\n        CountPrimes(limit);\n        auto t1 = std::chrono::high_resolution_clock::now();\n        double dt = std::chrono::duration<double>(t1 - t0).count();\n        latencies.push_back(dt);\n        total_time += dt;\n    }\n\n    double ops_per_sec = rounds / total_time;\n    std::sort(latencies.begin(), latencies.end());\n    double p99 = latencies.empty() ? 0.0\n        : latencies[(size_t)(0.99 * (latencies.size() - 1))];\n\n    std::ostringstream os;\n    os.setf(std::ios::fixed);\n    os.precision(6);\n    os << \"{\\\"ops_per_sec\\\":\" << ops_per_sec\n       << \",\\\"p99_latency_us\\\":\" << (p99 * 1e6)\n       << \",\\\"prime_count\\\":\" << got_count << \"}\";\n    WriteJson(json_path, os.str());\n    return 0;\n}\n```\nKey features: Performs well on combined_score (1.3103), Performs well on ops_per_sec (40.4803), Performs well on p99_latency_us (24732.6260), Performs well on bcoz_max_speedup (5.0000), Performs well on bperf_offcpu_ratio (0.0200)\n\n### Program 3 (Score: 1.0455)\n```cpp\n#include <algorithm>\n#include <chrono>\n#include <cmath>\n#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n\n// Reference: pi(10^7) = 664579\nstatic int ReferencePrimeCount(int limit) {\n    std::vector<bool> is_prime(limit + 1, true);\n    is_prime[0] = is_prime[1] = false;\n    for (int i = 2; (long long)i * i <= limit; ++i) {\n        if (is_prime[i]) {\n            for (int j = i * i; j <= limit; j += i)\n                is_prime[j] = false;\n        }\n    }\n    int count = 0;\n    for (int i = 2; i <= limit; ++i)\n        if (is_prime[i]) ++count;\n    return count;\n}\n\n// EVOLVE-BLOCK-START\n\nstatic int CountPrimes(int limit) {\n    // Naive sieve: one byte per element, no segmentation, no wheel\n    std::vector<uint8_t> sieve(limit + 1, 1);\n    sieve[0] = sieve[1] = 0;\n    for (int i = 2; (long long)i * i <= limit; ++i) {\n        if (sieve[i]) {\n            for (int j = i * i; j <= limit; j += i) {\n                sieve[j] = 0;\n            }\n        }\n    }\n    int count = 0;\n    for (int i = 2; i <= limit; ++i) {\n        count += sieve[i];\n    }\n    return count;\n}\n\n// EVOLVE-BLOCK-END\n\nstatic void WriteJson(const std::string &path, const std::string &payload) {\n    if (path.empty()) { std::cout << payload << std::endl; return; }\n    std::ofstream out(path.c_str(), std::ios::binary);\n    out << payload;\n}\n\nint main(int argc, char **argv) {\n    std::string json_path;\n    int limit = 10000000;  // 10^7\n    int rounds = 10;\n\n    for (int i = 1; i < argc; ++i) {\n        std::string arg = argv[i];\n        if (arg == \"--json\" && i + 1 < argc) json_path = argv[++i];\n        else if (arg == \"--limit\" && i + 1 < argc) limit = std::atoi(argv[++i]);\n        else if (arg == \"--rounds\" && i + 1 < argc) rounds = std::atoi(argv[++i]);\n    }\n\n    // Correctness check\n    int ref_count = ReferencePrimeCount(limit);\n    int got_count = CountPrimes(limit);\n    if (ref_count != got_count) {\n        std::cerr << \"prime count mismatch: expected \" << ref_count\n                  << \" got \" << got_count << std::endl;\n        return 2;\n    }\n\n    // Benchmark\n    std::vector<double> latencies;\n    latencies.reserve(rounds);\n    double total_time = 0.0;\n\n    for (int r = 0; r < rounds; ++r) {\n        auto t0 = std::chrono::high_resolution_clock::now();\n        CountPrimes(limit);\n        auto t1 = std::chrono::high_resolution_clock::now();\n        double dt = std::chrono::duration<double>(t1 - t0).count();\n        latencies.push_back(dt);\n        total_time += dt;\n    }\n\n    double ops_per_sec = rounds / total_time;\n    std::sort(latencies.begin(), latencies.end());\n    double p99 = latencies.empty() ? 0.0\n        : latencies[(size_t)(0.99 * (latencies.size() - 1))];\n\n    std::ostringstream os;\n    os.setf(std::ios::fixed);\n    os.precision(6);\n    os << \"{\\\"ops_per_sec\\\":\" << ops_per_sec\n       << \",\\\"p99_latency_us\\\":\" << (p99 * 1e6)\n       << \",\\\"prime_count\\\":\" << got_count << \"}\";\n    WriteJson(json_path, os.str());\n    return 0;\n}\n\n```\nKey features: Performs well on combined_score (1.0455), Performs well on ops_per_sec (32.2120), Performs well on p99_latency_us (30776.6090), Performs well on bcoz_max_speedup (5.0000), Performs well on bperf_offcpu_ratio (0.0200)\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 1.0455, Type: High-Performer)\n```cpp\n#include <algorithm>\n#include <chrono>\n#include <cmath>\n#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n\n// Reference: pi(10^7) = 664579\nstatic int ReferencePrimeCount(int limit) {\n    std::vector<bool> is_prime(limit + 1, true);\n    is_prime[0] = is_prime[1] = false;\n    for (int i = 2; (long long)i * i <= limit; ++i) {\n        if (is_prime[i]) {\n            for (int j = i * i; j <= limit; j += i)\n                is_prime[j] = false;\n        }\n    }\n    int count = 0;\n    for (int i = 2; i <= limit; ++i)\n        if (is_prime[i]) ++count;\n    return count;\n}\n\n// EVOLVE-BLOCK-START\n\nstatic int CountPrimes(int limit) {\n    // Naive sieve: one byte per element, no segmentation, no wheel\n    std::vector<uint8_t> sieve(limit + 1, 1);\n    sieve[0] = sieve[1] = 0;\n    for (int i = 2; (long long)i * i <= limit; ++i) {\n        if (sieve[i]) {\n            for (int j = i * i; j <= limit; j += i) {\n                sieve[j] = 0;\n            }\n        }\n    }\n    int count = 0;\n    for (int i = 2; i <= limit; ++i) {\n        count += sieve[i];\n    }\n    return count;\n}\n\n// EVOLVE-BLOCK-END\n\nstatic void WriteJson(const std::string &path, const std::string &payload) {\n    if (path.empty()) { std::cout << payload << std::endl; return; }\n    std::ofstream out(path.c_str(), std::ios::binary);\n    out << payload;\n}\n\nint main(int argc, char **argv) {\n    std::string json_path;\n    int limit = 10000000;  // 10^7\n    int rounds = 10;\n\n    for (int i = 1; i < argc; ++i) {\n        std::string arg = argv[i];\n        if (arg == \"--json\" && i + 1 < argc) json_path = argv[++i];\n        else if (arg == \"--limit\" && i + 1 < argc) limit = std::atoi(argv[++i]);\n        else if (arg == \"--rounds\" && i + 1 < argc) rounds = std::atoi(argv[++i]);\n    }\n\n    // Correctness check\n    int ref_count = ReferencePrimeCount(limit);\n    int got_count = CountPrimes(limit);\n    if (ref_count != got_count) {\n        std::cerr << \"prime count mismatch: expected \" << ref_count\n                  << \" got \" << got_count << std::endl;\n        return 2;\n    }\n\n    // Benchmark\n    std::vector<double> latencies;\n    latencies.reserve(rounds);\n    double total_time = 0.0;\n\n    for (int r = 0; r < rounds; ++r) {\n        auto t0 = std::chrono::high_resolution_clock::now();\n        CountPrimes(limit);\n        auto t1 = std::chrono::high_resolution_clock::now();\n        double dt = std::chrono::duration<double>(t1 - t0).count();\n        latencies.push_back(dt);\n        total_time += dt;\n    }\n\n    double ops_per_sec = rounds / total_time;\n    std::sort(latencies.begin(), latencies.end());\n    double p99 = latencies.empty() ? 0.0\n        : latencies[(size_t)(0.99 * (latencies.size() - 1))];\n\n    std::ostringstream os;\n    os.setf(std::ios::fixed);\n    os.precision(6);\n    os << \"{\\\"ops_per_sec\\\":\" << ops_per_sec\n       << \",\\\"p99_latency_us\\\":\" << (p99 * 1e6)\n       << \",\\\"prime_count\\\":\" << got_count << \"}\";\n    WriteJson(json_path, os.str());\n    return 0;\n}\n\n```\nUnique approach: [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 1.3104, Type: High-Performer)\n```cpp\n#include <algorithm>\n#include <chrono>\n#include <cmath>\n#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n\n// Reference: pi(10^7) = 664579\nstatic int ReferencePrimeCount(int limit) {\n    std::vector<bool> is_prime(limit + 1, true);\n    is_prime[0] = is_prime[1] = false;\n    for (int i = 2; (long long)i * i <= limit; ++i) {\n        if (is_prime[i]) {\n            for (int j = i * i; j <= limit; j += i)\n                is_prime[j] = false;\n        }\n    }\n    int count = 0;\n    for (int i = 2; i <= limit; ++i)\n        if (is_prime[i]) ++count;\n    return count;\n}\n\n// EVOLVE-BLOCK-START\n\nstatic int CountPrimes(int limit) {\n    if (limit < 2) return 0;\n    \n    // Use bool vector for better cache locality and bit operations\n    std::vector<bool> is_prime(limit + 1, true);\n    is_prime[0] = is_prime[1] = false;\n    \n    // Only check odd numbers after 2\n    const int sqrt_limit = static_cast<int>(std::sqrt(limit)) + 1;\n    \n    // Handle 2 separately\n    for (int j = 4; j <= limit; j += 2) {\n        is_prime[j] = false;\n    }\n    \n    // Process odd numbers only\n    for (int i = 3; i < sqrt_limit; i += 2) {\n        if (is_prime[i]) {\n            // Start marking from i*i, and increment by 2*i to skip even multiples\n            for (int j = i * i; j <= limit; j += 2 * i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n    \n    // Count primes (skip even numbers except 2)\n    int count = 1; // Account for 2\n    for (int i = 3; i <= limit; i += 2) {\n        count += is_prime[i];\n    }\n    \n    return count;\n}\n\n// EVOLVE-BLOCK-END\n\nstatic void WriteJson(const std::string &path, const std::string &payload) {\n    if (path.empty()) { std::cout << payload << std::endl; return; }\n    std::ofstream out(path.c_str(), std::ios::binary);\n    out << payload;\n}\n\nint main(int argc, char **argv) {\n    std::string json_path;\n    int limit = 10000000;  // 10^7\n    int rounds = 10;\n\n    for (int i = 1; i < argc; ++i) {\n        std::string arg = argv[i];\n        if (arg == \"--json\" && i + 1 < argc) json_path = argv[++i];\n        else if (arg == \"--limit\" && i + 1 < argc) limit = std::atoi(argv[++i]);\n        else if (arg == \"--rounds\" && i + 1 < argc) rounds = std::atoi(argv[++i]);\n    }\n\n    // Correctness check\n    int ref_count = ReferencePrimeCount(limit);\n    int got_count = CountPrimes(limit);\n    if (ref_count != got_count) {\n        std::cerr << \"prime count mismatch: expected \" << ref_count\n                  << \" got \" << got_count << std::endl;\n        return 2;\n    }\n\n    // Benchmark\n    std::vector<double> latencies;\n    latencies.reserve(rounds);\n    double total_time = 0.0;\n\n    for (int r = 0; r < rounds; ++r) {\n        auto t0 = std::chrono::high_resolution_clock::now();\n        CountPrimes(limit);\n        auto t1 = std::chrono::high_resolution_clock::now();\n        double dt = std::chrono::duration<double>(t1 - t0).count();\n        latencies.push_back(dt);\n        total_time += dt;\n    }\n\n    double ops_per_sec = rounds / total_time;\n    std::sort(latencies.begin(), latencies.end());\n    double p99 = latencies.empty() ? 0.0\n        : latencies[(size_t)(0.99 * (latencies.size() - 1))];\n\n    std::ostringstream os;\n    os.setf(std::ios::fixed);\n    os.precision(6);\n    os << \"{\\\"ops_per_sec\\\":\" << ops_per_sec\n       << \",\\\"p99_latency_us\\\":\" << (p99 * 1e6)\n       << \",\\\"prime_count\\\":\" << got_count << \"}\";\n    WriteJson(json_path, os.str());\n    return 0;\n}\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```cpp\n#include <algorithm>\n#include <chrono>\n#include <cmath>\n#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n\n// Reference: pi(10^7) = 664579\nstatic int ReferencePrimeCount(int limit) {\n    std::vector<bool> is_prime(limit + 1, true);\n    is_prime[0] = is_prime[1] = false;\n    for (int i = 2; (long long)i * i <= limit; ++i) {\n        if (is_prime[i]) {\n            for (int j = i * i; j <= limit; j += i)\n                is_prime[j] = false;\n        }\n    }\n    int count = 0;\n    for (int i = 2; i <= limit; ++i)\n        if (is_prime[i]) ++count;\n    return count;\n}\n\n// EVOLVE-BLOCK-START\n\nstatic int CountPrimes(int limit) {\n    if (limit < 2) return 0;\n    \n    // Use bool vector for better cache locality and bit operations\n    std::vector<bool> is_prime(limit + 1, true);\n    is_prime[0] = is_prime[1] = false;\n    \n    // Only check odd numbers after 2\n    const int sqrt_limit = static_cast<int>(std::sqrt(limit)) + 1;\n    \n    // Handle 2 separately\n    for (int j = 4; j <= limit; j += 2) {\n        is_prime[j] = false;\n    }\n    \n    // Process odd numbers only\n    for (int i = 3; i < sqrt_limit; i += 2) {\n        if (is_prime[i]) {\n            // Start marking from i*i, and increment by 2*i to skip even multiples\n            for (int j = i * i; j <= limit; j += 2 * i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n    \n    // Count primes (skip even numbers except 2)\n    int count = 1; // Account for 2\n    for (int i = 3; i <= limit; i += 2) {\n        count += is_prime[i];\n    }\n    \n    return count;\n}\n\n// EVOLVE-BLOCK-END\n\nstatic void WriteJson(const std::string &path, const std::string &payload) {\n    if (path.empty()) { std::cout << payload << std::endl; return; }\n    std::ofstream out(path.c_str(), std::ios::binary);\n    out << payload;\n}\n\nint main(int argc, char **argv) {\n    std::string json_path;\n    int limit = 10000000;  // 10^7\n    int rounds = 10;\n\n    for (int i = 1; i < argc; ++i) {\n        std::string arg = argv[i];\n        if (arg == \"--json\" && i + 1 < argc) json_path = argv[++i];\n        else if (arg == \"--limit\" && i + 1 < argc) limit = std::atoi(argv[++i]);\n        else if (arg == \"--rounds\" && i + 1 < argc) rounds = std::atoi(argv[++i]);\n    }\n\n    // Correctness check\n    int ref_count = ReferencePrimeCount(limit);\n    int got_count = CountPrimes(limit);\n    if (ref_count != got_count) {\n        std::cerr << \"prime count mismatch: expected \" << ref_count\n                  << \" got \" << got_count << std::endl;\n        return 2;\n    }\n\n    // Benchmark\n    std::vector<double> latencies;\n    latencies.reserve(rounds);\n    double total_time = 0.0;\n\n    for (int r = 0; r < rounds; ++r) {\n        auto t0 = std::chrono::high_resolution_clock::now();\n        CountPrimes(limit);\n        auto t1 = std::chrono::high_resolution_clock::now();\n        double dt = std::chrono::duration<double>(t1 - t0).count();\n        latencies.push_back(dt);\n        total_time += dt;\n    }\n\n    double ops_per_sec = rounds / total_time;\n    std::sort(latencies.begin(), latencies.end());\n    double p99 = latencies.empty() ? 0.0\n        : latencies[(size_t)(0.99 * (latencies.size() - 1))];\n\n    std::ostringstream os;\n    os.setf(std::ios::fixed);\n    os.precision(6);\n    os << \"{\\\"ops_per_sec\\\":\" << ops_per_sec\n       << \",\\\"p99_latency_us\\\":\" << (p99 * 1e6)\n       << \",\\\"prime_count\\\":\" << got_count << \"}\";\n    WriteJson(json_path, os.str());\n    return 0;\n}\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: ops_per_sec, p99_latency_us\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```cpp\n# Your rewritten program here\n```", "responses": ["```cpp\n#include <algorithm>\n#include <chrono>\n#include <cmath>\n#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n\n// Reference: pi(10^7) = 664579\nstatic int ReferencePrimeCount(int limit) {\n    std::vector<bool> is_prime(limit + 1, true);\n    is_prime[0] = is_prime[1] = false;\n    for (int i = 2; (long long)i * i <= limit; ++i) {\n        if (is_prime[i]) {\n            for (int j = i * i; j <= limit; j += i)\n                is_prime[j] = false;\n        }\n    }\n    int count = 0;\n    for (int i = 2; i <= limit; ++i)\n        if (is_prime[i]) ++count;\n    return count;\n}\n\n// EVOLVE-BLOCK-START\n\nstatic int CountPrimes(int limit) {\n    if (limit < 2) return 0;\n    \n    // Use bool vector for better cache locality and bit operations\n    std::vector<bool> is_prime(limit + 1, true);\n    is_prime[0] = is_prime[1] = false;\n    \n    // Only check odd numbers after 2\n    const int sqrt_limit = static_cast<int>(std::sqrt(limit)) + 1;\n    \n    // Handle 2 separately\n    for (int j = 4; j <= limit; j += 2) {\n        is_prime[j] = false;\n    }\n    \n    // Process odd numbers only\n    for (int i = 3; i < sqrt_limit; i += 2) {\n        if (is_prime[i]) {\n            // Start marking from i*i, and increment by 2*i to skip even multiples\n            for (int j = i * i; j <= limit; j += 2 * i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n    \n    // Count primes (skip even numbers except 2)\n    int count = 1; // Account for 2\n    for (int i = 3; i <= limit; i += 2) {\n        count += is_prime[i];\n    }\n    \n    return count;\n}\n\n// EVOLVE-BLOCK-END\n\nstatic void WriteJson(const std::string &path, const std::string &payload) {\n    if (path.empty()) { std::cout << payload << std::endl; return; }\n    std::ofstream out(path.c_str(), std::ios::binary);\n    out << payload;\n}\n\nint main(int argc, char **argv) {\n    std::string json_path;\n    int limit = 10000000;  // 10^7\n    int rounds = 10;\n\n    for (int i = 1; i < argc; ++i) {\n        std::string arg = argv[i];\n        if (arg == \"--json\" && i + 1 < argc) json_path = argv[++i];\n        else if (arg == \"--limit\" && i + 1 < argc) limit = std::atoi(argv[++i]);\n        else if (arg == \"--rounds\" && i + 1 < argc) rounds = std::atoi(argv[++i]);\n    }\n\n    // Correctness check\n    int ref_count = ReferencePrimeCount(limit);\n    int got_count = CountPrimes(limit);\n    if (ref_count != got_count) {\n        std::cerr << \"prime count mismatch: expected \" << ref_count\n                  << \" got \" << got_count << std::endl;\n        return 2;\n    }\n\n    // Benchmark\n    std::vector<double> latencies;\n    latencies.reserve(rounds);\n    double total_time = 0.0;\n\n    for (int r = 0; r < rounds; ++r) {\n        auto t0 = std::chrono::high_resolution_clock::now();\n        CountPrimes(limit);\n        auto t1 = std::chrono::high_resolution_clock::now();\n        double dt = std::chrono::duration<double>(t1 - t0).count();\n        latencies.push_back(dt);\n        total_time += dt;\n    }\n\n    double ops_per_sec = rounds / total_time;\n    std::sort(latencies.begin(), latencies.end());\n    double p99 = latencies.empty() ? 0.0\n        : latencies[(size_t)(0.99 * (latencies.size() - 1))];\n\n    std::ostringstream os;\n    os.setf(std::ios::fixed);\n    os.precision(6);\n    os << \"{\\\"ops_per_sec\\\":\" << ops_per_sec\n       << \",\\\"p99_latency_us\\\":\" << (p99 * 1e6)\n       << \",\\\"prime_count\\\":\" << got_count << \"}\";\n    WriteJson(json_path, os.str());\n    return 0;\n}\n```"]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}