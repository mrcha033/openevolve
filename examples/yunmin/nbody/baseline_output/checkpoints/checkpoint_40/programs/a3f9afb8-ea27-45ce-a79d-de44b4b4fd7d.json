{"id": "a3f9afb8-ea27-45ce-a79d-de44b4b4fd7d", "code": "#include <algorithm>\n#include <chrono>\n#include <cmath>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n#include <random>\n#include <sstream>\n#include <string>\n#include <vector>\n\n// Array-of-Structures layout (deliberately naive for cache performance)\nstruct Body {\n    double x, y, z;\n    double vx, vy, vz;\n    double mass;\n};\n\n// Reference implementation (outside EVOLVE-BLOCK, used for correctness check)\nstatic void ReferenceForces(const std::vector<Body> &bodies,\n                            std::vector<double> &fx,\n                            std::vector<double> &fy,\n                            std::vector<double> &fz) {\n    int n = (int)bodies.size();\n    fx.assign(n, 0.0);\n    fy.assign(n, 0.0);\n    fz.assign(n, 0.0);\n    const double eps2 = 1e-9;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            double dx = bodies[j].x - bodies[i].x;\n            double dy = bodies[j].y - bodies[i].y;\n            double dz = bodies[j].z - bodies[i].z;\n            double r2 = dx * dx + dy * dy + dz * dz + eps2;\n            double inv_r = 1.0 / std::sqrt(r2);\n            double inv_r3 = inv_r * inv_r * inv_r;\n            double fi = bodies[j].mass * inv_r3;\n            double fj = bodies[i].mass * inv_r3;\n            fx[i] += dx * fi; fy[i] += dy * fi; fz[i] += dz * fi;\n            fx[j] -= dx * fj; fy[j] -= dy * fj; fz[j] -= dz * fj;\n        }\n    }\n}\n\n// EVOLVE-BLOCK-START\n\nstatic void ComputeForces(const std::vector<Body> &bodies,\n                          std::vector<double> &fx,\n                          std::vector<double> &fy,\n                          std::vector<double> &fz) {\n    int n = (int)bodies.size();\n    fx.assign(n, 0.0);\n    fy.assign(n, 0.0);\n    fz.assign(n, 0.0);\n    const double eps2 = 1e-9;\n    \n    // Optimized loop with reduced operations and better instruction scheduling\n    for (int i = 0; i < n; ++i) {\n        const Body& bi = bodies[i];\n        const double xi = bi.x;\n        const double yi = bi.y;\n        const double zi = bi.z;\n        const double mi = bi.mass;\n        \n        for (int j = i + 1; j < n; ++j) {\n            const Body& bj = bodies[j];\n            double dx = bj.x - xi;\n            double dy = bj.y - yi;\n            double dz = bj.z - zi;\n            double r2 = dx * dx + dy * dy + dz * dz + eps2;\n            \n            // Compute inverse sqrt once and reuse\n            double inv_r = 1.0 / std::sqrt(r2);\n            double inv_r3 = inv_r * inv_r * inv_r;\n            \n            // Precompute force magnitudes to avoid redundant multiplications\n            double force_mag_j = bj.mass * inv_r3;\n            double force_mag_i = mi * inv_r3;\n            \n            // Apply forces to both bodies - reordered for better instruction scheduling\n            fx[i] += dx * force_mag_i;\n            fy[i] += dy * force_mag_i;\n            fz[i] += dz * force_mag_i;\n            \n            fx[j] -= dx * force_mag_j;\n            fy[j] -= dy * force_mag_j;\n            fz[j] -= dz * force_mag_j;\n        }\n    }\n}\n\n// EVOLVE-BLOCK-END\n\nstatic std::vector<Body> GenerateBodies(std::mt19937 &rng, int n) {\n    std::uniform_real_distribution<double> pos(-100.0, 100.0);\n    std::uniform_real_distribution<double> vel(-1.0, 1.0);\n    std::uniform_real_distribution<double> m(0.1, 10.0);\n    std::vector<Body> bodies(n);\n    for (int i = 0; i < n; ++i) {\n        bodies[i] = {pos(rng), pos(rng), pos(rng),\n                     vel(rng), vel(rng), vel(rng), m(rng)};\n    }\n    return bodies;\n}\n\nstatic void WriteJson(const std::string &path, const std::string &payload) {\n    if (path.empty()) { std::cout << payload << std::endl; return; }\n    std::ofstream out(path.c_str(), std::ios::binary);\n    out << payload;\n}\n\nint main(int argc, char **argv) {\n    std::string json_path;\n    int seed = 42;\n    int num_bodies = 1024;\n    int rounds = 20;\n\n    for (int i = 1; i < argc; ++i) {\n        std::string arg = argv[i];\n        if (arg == \"--json\" && i + 1 < argc) json_path = argv[++i];\n        else if (arg == \"--seed\" && i + 1 < argc) seed = std::atoi(argv[++i]);\n        else if (arg == \"--bodies\" && i + 1 < argc) num_bodies = std::atoi(argv[++i]);\n        else if (arg == \"--rounds\" && i + 1 < argc) rounds = std::atoi(argv[++i]);\n    }\n\n    std::mt19937 rng(seed);\n    auto bodies = GenerateBodies(rng, num_bodies);\n\n    // Correctness check\n    std::vector<double> ref_fx, ref_fy, ref_fz;\n    std::vector<double> fx, fy, fz;\n    ReferenceForces(bodies, ref_fx, ref_fy, ref_fz);\n    ComputeForces(bodies, fx, fy, fz);\n    for (int i = 0; i < num_bodies; ++i) {\n        double mag = std::abs(ref_fx[i]) + std::abs(ref_fy[i]) + std::abs(ref_fz[i]);\n        double err = std::abs(fx[i] - ref_fx[i]) + std::abs(fy[i] - ref_fy[i])\n                   + std::abs(fz[i] - ref_fz[i]);\n        // Relative tolerance: allow FP reordering from SIMD/SoA/tiling\n        double tol = std::max(1e-6, mag * 1e-6);\n        if (err > tol) {\n            std::cerr << \"force mismatch at body \" << i\n                      << \" err=\" << err << \" tol=\" << tol << std::endl;\n            return 2;\n        }\n    }\n\n    // Benchmark\n    std::vector<double> latencies;\n    latencies.reserve(rounds);\n    double total_time = 0.0;\n\n    for (int r = 0; r < rounds; ++r) {\n        auto t0 = std::chrono::high_resolution_clock::now();\n        ComputeForces(bodies, fx, fy, fz);\n        auto t1 = std::chrono::high_resolution_clock::now();\n        double dt = std::chrono::duration<double>(t1 - t0).count();\n        latencies.push_back(dt);\n        total_time += dt;\n    }\n\n    double ops_per_sec = rounds / total_time;\n    std::sort(latencies.begin(), latencies.end());\n    double p99 = latencies.empty() ? 0.0\n        : latencies[(size_t)(0.99 * (latencies.size() - 1))];\n\n    std::ostringstream os;\n    os.setf(std::ios::fixed);\n    os.precision(6);\n    os << \"{\\\"ops_per_sec\\\":\" << ops_per_sec\n       << \",\\\"p99_latency_us\\\":\" << (p99 * 1e6)\n       << \",\\\"num_bodies\\\":\" << num_bodies << \"}\";\n    WriteJson(json_path, os.str());\n    return 0;\n}", "changes_description": null, "language": "cpp", "parent_id": "17bea392-b965-44f4-ad6e-12e4940c44ab", "generation": 2, "timestamp": 1770565293.678726, "iteration_found": 19, "metrics": {"combined_score": 0.0, "error": "nbody failed: force mismatch at body 0 err=0.0978338 tol=1e-06", "ops_per_sec": 0.0, "p99_latency_us": 0.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"combined_score": 1.4215, "ops_per_sec": 363.232027, "p99_latency_us": 2808.827, "bcoz_max_speedup": 5.0, "bperf_offcpu_ratio": 0.02}, "island": 0}, "prompts": {"full_rewrite_user": {"system": "You are a C++ performance optimization expert.\nOptimize the N-body force computation inside the EVOLVE-BLOCK.\n\nRequirements:\n- Only modify code inside the EVOLVE-BLOCK.\n- Keep the function signature: void ComputeForces(const vector<Body>&, vector<double>&, vector<double>&, vector<double>&)\n- The Body struct has fields: x, y, z, vx, vy, vz, mass.\n- Must compute gravitationally correct pairwise forces with softening eps2 = 1e-9.\n- Results must match the reference within 1e-6 relative error per body.\n- Use only the C++ standard library. No external dependencies.\n- Do not add top-level side effects or debug printing.\n\nMake the force computation as fast as possible.\n", "user": "# Current Program Information\n- Fitness: 1.4215\n- Feature coordinates: ops_per_sec=363.23, p99_latency_us=2808.83\n- Focus areas: - Fitness improved: 0.0000 \u2192 1.4215\n- Exploring ops_per_sec=363.23, p99_latency_us=2808.83 region of solution space\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: combined_score: 0.0000, error: nbody failed: force mismatch at body 0 err=0.0978338 tol=1e-06, ops_per_sec: 0.0000, p99_latency_us: 0.0000\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Unknown changes\n- Metrics: combined_score: 1.4086, ops_per_sec: 357.8303, p99_latency_us: 2807.8670, bcoz_max_speedup: 5.0000, bperf_offcpu_ratio: 0.0200\n- Outcome: Improvement in all metrics\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: combined_score: 1.4215, ops_per_sec: 363.2320, p99_latency_us: 2808.8270, bcoz_max_speedup: 5.0000, bperf_offcpu_ratio: 0.0200\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 1.4215)\n```cpp\n#include <algorithm>\n#include <chrono>\n#include <cmath>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n#include <random>\n#include <sstream>\n#include <string>\n#include <vector>\n\n// Array-of-Structures layout (deliberately naive for cache performance)\nstruct Body {\n    double x, y, z;\n    double vx, vy, vz;\n    double mass;\n};\n\n// Reference implementation (outside EVOLVE-BLOCK, used for correctness check)\nstatic void ReferenceForces(const std::vector<Body> &bodies,\n                            std::vector<double> &fx,\n                            std::vector<double> &fy,\n                            std::vector<double> &fz) {\n    int n = (int)bodies.size();\n    fx.assign(n, 0.0);\n    fy.assign(n, 0.0);\n    fz.assign(n, 0.0);\n    const double eps2 = 1e-9;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            double dx = bodies[j].x - bodies[i].x;\n            double dy = bodies[j].y - bodies[i].y;\n            double dz = bodies[j].z - bodies[i].z;\n            double r2 = dx * dx + dy * dy + dz * dz + eps2;\n            double inv_r = 1.0 / std::sqrt(r2);\n            double inv_r3 = inv_r * inv_r * inv_r;\n            double fi = bodies[j].mass * inv_r3;\n            double fj = bodies[i].mass * inv_r3;\n            fx[i] += dx * fi; fy[i] += dy * fi; fz[i] += dz * fi;\n            fx[j] -= dx * fj; fy[j] -= dy * fj; fz[j] -= dz * fj;\n        }\n    }\n}\n\n// EVOLVE-BLOCK-START\n\nstatic void ComputeForces(const std::vector<Body> &bodies,\n                          std::vector<double> &fx,\n                          std::vector<double> &fy,\n                          std::vector<double> &fz) {\n    int n = (int)bodies.size();\n    fx.assign(n, 0.0);\n    fy.assign(n, 0.0);\n    fz.assign(n, 0.0);\n    const double eps2 = 1e-9;\n    \n    // Loop unrolling and manual vectorization for better performance\n    for (int i = 0; i < n; ++i) {\n        const Body& bi = bodies[i];\n        for (int j = i + 1; j < n; ++j) {\n            const Body& bj = bodies[j];\n            double dx = bj.x - bi.x;\n            double dy = bj.y - bi.y;\n            double dz = bj.z - bi.z;\n            double r2 = dx * dx + dy * dy + dz * dz + eps2;\n            \n            // Use fast reciprocal square root approximation\n            double inv_r = 1.0 / std::sqrt(r2);\n            double inv_r3 = inv_r * inv_r * inv_r;\n            \n            double fi = bj.mass * inv_r3;\n            double fj = bi.mass * inv_r3;\n            \n            fx[i] += dx * fi;\n            fy[i] += dy * fi;\n            fz[i] += dz * fi;\n            \n            fx[j] -= dx * fj;\n            fy[j] -= dy * fj;\n            fz[j] -= dz * fj;\n        }\n    }\n}\n\n// EVOLVE-BLOCK-END\n\nstatic std::vector<Body> GenerateBodies(std::mt19937 &rng, int n) {\n    std::uniform_real_distribution<double> pos(-100.0, 100.0);\n    std::uniform_real_distribution<double> vel(-1.0, 1.0);\n    std::uniform_real_distribution<double> m(0.1, 10.0);\n    std::vector<Body> bodies(n);\n    for (int i = 0; i < n; ++i) {\n        bodies[i] = {pos(rng), pos(rng), pos(rng),\n                     vel(rng), vel(rng), vel(rng), m(rng)};\n    }\n    return bodies;\n}\n\nstatic void WriteJson(const std::string &path, const std::string &payload) {\n    if (path.empty()) { std::cout << payload << std::endl; return; }\n    std::ofstream out(path.c_str(), std::ios::binary);\n    out << payload;\n}\n\nint main(int argc, char **argv) {\n    std::string json_path;\n    int seed = 42;\n    int num_bodies = 1024;\n    int rounds = 20;\n\n    for (int i = 1; i < argc; ++i) {\n        std::string arg = argv[i];\n        if (arg == \"--json\" && i + 1 < argc) json_path = argv[++i];\n        else if (arg == \"--seed\" && i + 1 < argc) seed = std::atoi(argv[++i]);\n        else if (arg == \"--bodies\" && i + 1 < argc) num_bodies = std::atoi(argv[++i]);\n        else if (arg == \"--rounds\" && i + 1 < argc) rounds = std::atoi(argv[++i]);\n    }\n\n    std::mt19937 rng(seed);\n    auto bodies = GenerateBodies(rng, num_bodies);\n\n    // Correctness check\n    std::vector<double> ref_fx, ref_fy, ref_fz;\n    std::vector<double> fx, fy, fz;\n    ReferenceForces(bodies, ref_fx, ref_fy, ref_fz);\n    ComputeForces(bodies, fx, fy, fz);\n    for (int i = 0; i < num_bodies; ++i) {\n        double mag = std::abs(ref_fx[i]) + std::abs(ref_fy[i]) + std::abs(ref_fz[i]);\n        double err = std::abs(fx[i] - ref_fx[i]) + std::abs(fy[i] - ref_fy[i])\n                   + std::abs(fz[i] - ref_fz[i]);\n        // Relative tolerance: allow FP reordering from SIMD/SoA/tiling\n        double tol = std::max(1e-6, mag * 1e-6);\n        if (err > tol) {\n            std::cerr << \"force mismatch at body \" << i\n                      << \" err=\" << err << \" tol=\" << tol << std::endl;\n            return 2;\n        }\n    }\n\n    // Benchmark\n    std::vector<double> latencies;\n    latencies.reserve(rounds);\n    double total_time = 0.0;\n\n    for (int r = 0; r < rounds; ++r) {\n        auto t0 = std::chrono::high_resolution_clock::now();\n        ComputeForces(bodies, fx, fy, fz);\n        auto t1 = std::chrono::high_resolution_clock::now();\n        double dt = std::chrono::duration<double>(t1 - t0).count();\n        latencies.push_back(dt);\n        total_time += dt;\n    }\n\n    double ops_per_sec = rounds / total_time;\n    std::sort(latencies.begin(), latencies.end());\n    double p99 = latencies.empty() ? 0.0\n        : latencies[(size_t)(0.99 * (latencies.size() - 1))];\n\n    std::ostringstream os;\n    os.setf(std::ios::fixed);\n    os.precision(6);\n    os << \"{\\\"ops_per_sec\\\":\" << ops_per_sec\n       << \",\\\"p99_latency_us\\\":\" << (p99 * 1e6)\n       << \",\\\"num_bodies\\\":\" << num_bodies << \"}\";\n    WriteJson(json_path, os.str());\n    return 0;\n}\n```\nKey features: Performs well on combined_score (1.4215), Performs well on ops_per_sec (363.2320), Performs well on p99_latency_us (2808.8270), Performs well on bcoz_max_speedup (5.0000), Performs well on bperf_offcpu_ratio (0.0200)\n\n### Program 2 (Score: 1.4086)\n```cpp\n#include <algorithm>\n#include <chrono>\n#include <cmath>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n#include <random>\n#include <sstream>\n#include <string>\n#include <vector>\n\n// Array-of-Structures layout (deliberately naive for cache performance)\nstruct Body {\n    double x, y, z;\n    double vx, vy, vz;\n    double mass;\n};\n\n// Reference implementation (outside EVOLVE-BLOCK, used for correctness check)\nstatic void ReferenceForces(const std::vector<Body> &bodies,\n                            std::vector<double> &fx,\n                            std::vector<double> &fy,\n                            std::vector<double> &fz) {\n    int n = (int)bodies.size();\n    fx.assign(n, 0.0);\n    fy.assign(n, 0.0);\n    fz.assign(n, 0.0);\n    const double eps2 = 1e-9;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            double dx = bodies[j].x - bodies[i].x;\n            double dy = bodies[j].y - bodies[i].y;\n            double dz = bodies[j].z - bodies[i].z;\n            double r2 = dx * dx + dy * dy + dz * dz + eps2;\n            double inv_r = 1.0 / std::sqrt(r2);\n            double inv_r3 = inv_r * inv_r * inv_r;\n            double fi = bodies[j].mass * inv_r3;\n            double fj = bodies[i].mass * inv_r3;\n            fx[i] += dx * fi; fy[i] += dy * fi; fz[i] += dz * fi;\n            fx[j] -= dx * fj; fy[j] -= dy * fj; fz[j] -= dz * fj;\n        }\n    }\n}\n\n// EVOLVE-BLOCK-START\n\nstatic void ComputeForces(const std::vector<Body> &bodies,\n                          std::vector<double> &fx,\n                          std::vector<double> &fy,\n                          std::vector<double> &fz) {\n    int n = (int)bodies.size();\n    fx.assign(n, 0.0);\n    fy.assign(n, 0.0);\n    fz.assign(n, 0.0);\n    const double eps2 = 1e-9;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            double dx = bodies[j].x - bodies[i].x;\n            double dy = bodies[j].y - bodies[i].y;\n            double dz = bodies[j].z - bodies[i].z;\n            double r2 = dx * dx + dy * dy + dz * dz + eps2;\n            double inv_r = 1.0 / std::sqrt(r2);\n            double inv_r3 = inv_r * inv_r * inv_r;\n            double fi = bodies[j].mass * inv_r3;\n            double fj = bodies[i].mass * inv_r3;\n            fx[i] += dx * fi; fy[i] += dy * fi; fz[i] += dz * fi;\n            fx[j] -= dx * fj; fy[j] -= dy * fj; fz[j] -= dz * fj;\n        }\n    }\n}\n\n// EVOLVE-BLOCK-END\n\nstatic std::vector<Body> GenerateBodies(std::mt19937 &rng, int n) {\n    std::uniform_real_distribution<double> pos(-100.0, 100.0);\n    std::uniform_real_distribution<double> vel(-1.0, 1.0);\n    std::uniform_real_distribution<double> m(0.1, 10.0);\n    std::vector<Body> bodies(n);\n    for (int i = 0; i < n; ++i) {\n        bodies[i] = {pos(rng), pos(rng), pos(rng),\n                     vel(rng), vel(rng), vel(rng), m(rng)};\n    }\n    return bodies;\n}\n\nstatic void WriteJson(const std::string &path, const std::string &payload) {\n    if (path.empty()) { std::cout << payload << std::endl; return; }\n    std::ofstream out(path.c_str(), std::ios::binary);\n    out << payload;\n}\n\nint main(int argc, char **argv) {\n    std::string json_path;\n    int seed = 42;\n    int num_bodies = 1024;\n    int rounds = 20;\n\n    for (int i = 1; i < argc; ++i) {\n        std::string arg = argv[i];\n        if (arg == \"--json\" && i + 1 < argc) json_path = argv[++i];\n        else if (arg == \"--seed\" && i + 1 < argc) seed = std::atoi(argv[++i]);\n        else if (arg == \"--bodies\" && i + 1 < argc) num_bodies = std::atoi(argv[++i]);\n        else if (arg == \"--rounds\" && i + 1 < argc) rounds = std::atoi(argv[++i]);\n    }\n\n    std::mt19937 rng(seed);\n    auto bodies = GenerateBodies(rng, num_bodies);\n\n    // Correctness check\n    std::vector<double> ref_fx, ref_fy, ref_fz;\n    std::vector<double> fx, fy, fz;\n    ReferenceForces(bodies, ref_fx, ref_fy, ref_fz);\n    ComputeForces(bodies, fx, fy, fz);\n    for (int i = 0; i < num_bodies; ++i) {\n        double mag = std::abs(ref_fx[i]) + std::abs(ref_fy[i]) + std::abs(ref_fz[i]);\n        double err = std::abs(fx[i] - ref_fx[i]) + std::abs(fy[i] - ref_fy[i])\n                   + std::abs(fz[i] - ref_fz[i]);\n        // Relative tolerance: allow FP reordering from SIMD/SoA/tiling\n        double tol = std::max(1e-6, mag * 1e-6);\n        if (err > tol) {\n            std::cerr << \"force mismatch at body \" << i\n                      << \" err=\" << err << \" tol=\" << tol << std::endl;\n            return 2;\n        }\n    }\n\n    // Benchmark\n    std::vector<double> latencies;\n    latencies.reserve(rounds);\n    double total_time = 0.0;\n\n    for (int r = 0; r < rounds; ++r) {\n        auto t0 = std::chrono::high_resolution_clock::now();\n        ComputeForces(bodies, fx, fy, fz);\n        auto t1 = std::chrono::high_resolution_clock::now();\n        double dt = std::chrono::duration<double>(t1 - t0).count();\n        latencies.push_back(dt);\n        total_time += dt;\n    }\n\n    double ops_per_sec = rounds / total_time;\n    std::sort(latencies.begin(), latencies.end());\n    double p99 = latencies.empty() ? 0.0\n        : latencies[(size_t)(0.99 * (latencies.size() - 1))];\n\n    std::ostringstream os;\n    os.setf(std::ios::fixed);\n    os.precision(6);\n    os << \"{\\\"ops_per_sec\\\":\" << ops_per_sec\n       << \",\\\"p99_latency_us\\\":\" << (p99 * 1e6)\n       << \",\\\"num_bodies\\\":\" << num_bodies << \"}\";\n    WriteJson(json_path, os.str());\n    return 0;\n}\n\n```\nKey features: Performs well on combined_score (1.4086), Performs well on ops_per_sec (357.8303), Performs well on p99_latency_us (2807.8670), Performs well on bcoz_max_speedup (5.0000), Performs well on bperf_offcpu_ratio (0.0200)\n\n### Program 3 (Score: 0.0000)\n```cpp\n#include <algorithm>\n#include <chrono>\n#include <cmath>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n#include <random>\n#include <sstream>\n#include <string>\n#include <vector>\n\n// Array-of-Structures layout (deliberately naive for cache performance)\nstruct Body {\n    double x, y, z;\n    double vx, vy, vz;\n    double mass;\n};\n\n// Reference implementation (outside EVOLVE-BLOCK, used for correctness check)\nstatic void ReferenceForces(const std::vector<Body> &bodies,\n                            std::vector<double> &fx,\n                            std::vector<double> &fy,\n                            std::vector<double> &fz) {\n    int n = (int)bodies.size();\n    fx.assign(n, 0.0);\n    fy.assign(n, 0.0);\n    fz.assign(n, 0.0);\n    const double eps2 = 1e-9;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            double dx = bodies[j].x - bodies[i].x;\n            double dy = bodies[j].y - bodies[i].y;\n            double dz = bodies[j].z - bodies[i].z;\n            double r2 = dx * dx + dy * dy + dz * dz + eps2;\n            double inv_r = 1.0 / std::sqrt(r2);\n            double inv_r3 = inv_r * inv_r * inv_r;\n            double fi = bodies[j].mass * inv_r3;\n            double fj = bodies[i].mass * inv_r3;\n            fx[i] += dx * fi; fy[i] += dy * fi; fz[i] += dz * fi;\n            fx[j] -= dx * fj; fy[j] -= dy * fj; fz[j] -= dz * fj;\n        }\n    }\n}\n\n// EVOLVE-BLOCK-START\n\nstatic void ComputeForces(const std::vector<Body> &bodies,\n                          std::vector<double> &fx,\n                          std::vector<double> &fy,\n                          std::vector<double> &fz) {\n    int n = (int)bodies.size();\n    fx.assign(n, 0.0);\n    fy.assign(n, 0.0);\n    fz.assign(n, 0.0);\n    const double eps2 = 1e-9;\n    \n    // Optimized loop with reduced operations and better instruction scheduling\n    for (int i = 0; i < n; ++i) {\n        const Body& bi = bodies[i];\n        const double xi = bi.x;\n        const double yi = bi.y;\n        const double zi = bi.z;\n        const double mi = bi.mass;\n        \n        for (int j = i + 1; j < n; ++j) {\n            const Body& bj = bodies[j];\n            double dx = bj.x - xi;\n            double dy = bj.y - yi;\n            double dz = bj.z - zi;\n            double r2 = dx * dx + dy * dy + dz * dz + eps2;\n            \n            // Compute inverse sqrt once and reuse\n            double inv_r = 1.0 / std::sqrt(r2);\n            double inv_r3 = inv_r * inv_r * inv_r;\n            \n            // Precompute force magnitudes to avoid redundant multiplications\n            double force_mag_j = bj.mass * inv_r3;\n            double force_mag_i = mi * inv_r3;\n            \n            // Apply forces to both bodies - reordered for better instruction scheduling\n            fx[i] += dx * force_mag_i;\n            fy[i] += dy * force_mag_i;\n            fz[i] += dz * force_mag_i;\n            \n            fx[j] -= dx * force_mag_j;\n            fy[j] -= dy * force_mag_j;\n            fz[j] -= dz * force_mag_j;\n        }\n    }\n}\n\n// EVOLVE-BLOCK-END\n\nstatic std::vector<Body> GenerateBodies(std::mt19937 &rng, int n) {\n    std::uniform_real_distribution<double> pos(-100.0, 100.0);\n    std::uniform_real_distribution<double> vel(-1.0, 1.0);\n    std::uniform_real_distribution<double> m(0.1, 10.0);\n    std::vector<Body> bodies(n);\n    for (int i = 0; i < n; ++i) {\n        bodies[i] = {pos(rng), pos(rng), pos(rng),\n                     vel(rng), vel(rng), vel(rng), m(rng)};\n    }\n    return bodies;\n}\n\nstatic void WriteJson(const std::string &path, const std::string &payload) {\n    if (path.empty()) { std::cout << payload << std::endl; return; }\n    std::ofstream out(path.c_str(), std::ios::binary);\n    out << payload;\n}\n\nint main(int argc, char **argv) {\n    std::string json_path;\n    int seed = 42;\n    int num_bodies = 1024;\n    int rounds = 20;\n\n    for (int i = 1; i < argc; ++i) {\n        std::string arg = argv[i];\n        if (arg == \"--json\" && i + 1 < argc) json_path = argv[++i];\n        else if (arg == \"--seed\" && i + 1 < argc) seed = std::atoi(argv[++i]);\n        else if (arg == \"--bodies\" && i + 1 < argc) num_bodies = std::atoi(argv[++i]);\n        else if (arg == \"--rounds\" && i + 1 < argc) rounds = std::atoi(argv[++i]);\n    }\n\n    std::mt19937 rng(seed);\n    auto bodies = GenerateBodies(rng, num_bodies);\n\n    // Correctness check\n    std::vector<double> ref_fx, ref_fy, ref_fz;\n    std::vector<double> fx, fy, fz;\n    ReferenceForces(bodies, ref_fx, ref_fy, ref_fz);\n    ComputeForces(bodies, fx, fy, fz);\n    for (int i = 0; i < num_bodies; ++i) {\n        double mag = std::abs(ref_fx[i]) + std::abs(ref_fy[i]) + std::abs(ref_fz[i]);\n        double err = std::abs(fx[i] - ref_fx[i]) + std::abs(fy[i] - ref_fy[i])\n                   + std::abs(fz[i] - ref_fz[i]);\n        // Relative tolerance: allow FP reordering from SIMD/SoA/tiling\n        double tol = std::max(1e-6, mag * 1e-6);\n        if (err > tol) {\n            std::cerr << \"force mismatch at body \" << i\n                      << \" err=\" << err << \" tol=\" << tol << std::endl;\n            return 2;\n        }\n    }\n\n    // Benchmark\n    std::vector<double> latencies;\n    latencies.reserve(rounds);\n    double total_time = 0.0;\n\n    for (int r = 0; r < rounds; ++r) {\n        auto t0 = std::chrono::high_resolution_clock::now();\n        ComputeForces(bodies, fx, fy, fz);\n        auto t1 = std::chrono::high_resolution_clock::now();\n        double dt = std::chrono::duration<double>(t1 - t0).count();\n        latencies.push_back(dt);\n        total_time += dt;\n    }\n\n    double ops_per_sec = rounds / total_time;\n    std::sort(latencies.begin(), latencies.end());\n    double p99 = latencies.empty() ? 0.0\n        : latencies[(size_t)(0.99 * (latencies.size() - 1))];\n\n    std::ostringstream os;\n    os.setf(std::ios::fixed);\n    os.precision(6);\n    os << \"{\\\"ops_per_sec\\\":\" << ops_per_sec\n       << \",\\\"p99_latency_us\\\":\" << (p99 * 1e6)\n       << \",\\\"num_bodies\\\":\" << num_bodies << \"}\";\n    WriteJson(json_path, os.str());\n    return 0;\n}\n```\nKey features: Performs well on combined_score (0.0000), Performs well on error (nbody failed: force mismatch at body 0 err=0.0978338 tol=1e-06), Performs well on ops_per_sec (0.0000), Performs well on p99_latency_us (0.0000)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.0000)\n```cpp\n#include <algorithm>\n#include <chrono>\n#include <cmath>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n#include <random>\n#include <sstream>\n#include <string>\n#include <vector>\n\n// Array-of-Structures layout (deliberately naive for cache performance)\nstruct Body {\n    double x, y, z;\n    double vx, vy, vz;\n    double mass;\n};\n\n// Reference implementation (outside EVOLVE-BLOCK, used for correctness check)\nstatic void ReferenceForces(const std::vector<Body> &bodies,\n                            std::vector<double> &fx,\n                            std::vector<double> &fy,\n                            std::vector<double> &fz) {\n    int n = (int)bodies.size();\n    fx.assign(n, 0.0);\n    fy.assign(n, 0.0);\n    fz.assign(n, 0.0);\n    const double eps2 = 1e-9;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            double dx = bodies[j].x - bodies[i].x;\n            double dy = bodies[j].y - bodies[i].y;\n            double dz = bodies[j].z - bodies[i].z;\n            double r2 = dx * dx + dy * dy + dz * dz + eps2;\n            double inv_r = 1.0 / std::sqrt(r2);\n            double inv_r3 = inv_r * inv_r * inv_r;\n            double fi = bodies[j].mass * inv_r3;\n            double fj = bodies[i].mass * inv_r3;\n            fx[i] += dx * fi; fy[i] += dy * fi; fz[i] += dz * fi;\n            fx[j] -= dx * fj; fy[j] -= dy * fj; fz[j] -= dz * fj;\n        }\n    }\n}\n\n// EVOLVE-BLOCK-START\n\nstatic void ComputeForces(const std::vector<Body> &bodies,\n                          std::vector<double> &fx,\n                          std::vector<double> &fy,\n                          std::vector<double> &fz) {\n    int n = (int)bodies.size();\n    fx.assign(n, 0.0);\n    fy.assign(n, 0.0);\n    fz.assign(n, 0.0);\n    const double eps2 = 1e-9;\n    \n    // Optimized loop with reduced memory accesses and better instruction scheduling\n    for (int i = 0; i < n; ++i) {\n        const Body& bi = bodies[i];\n        const double xi = bi.x;\n        const double yi = bi.y;\n        const double zi = bi.z;\n        const double mi = bi.mass;\n        \n        for (int j = i + 1; j < n; ++j) {\n            const Body& bj = bodies[j];\n            double dx = bj.x - xi;\n            double dy = bj.y - yi;\n            double dz = bj.z - zi;\n            double r2 = dx * dx + dy * dy + dz * dz + eps2;\n            \n            // Single reciprocal square root call for better performance\n            double inv_r = 1.0 / std::sqrt(r2);\n            double inv_r3 = inv_r * inv_r * inv_r;\n            \n            double force_magnitude = bj.mass * inv_r3;\n            double force_i = force_magnitude * mi;\n            \n            // Apply forces to both bodies\n            fx[i] += dx * force_i;\n            fy[i] += dy * force_i;\n            fz[i] += dz * force_i;\n            \n            fx[j] -= dx * force_magnitude;\n            fy[j] -= dy * force_magnitude;\n            fz[j] -= dz * force_magnitude;\n        }\n    }\n}\n\n// EVOLVE-BLOCK-END\n\nstatic std::vector<Body> GenerateBodies(std::mt19937 &rng, int n) {\n    std::uniform_real_distribution<double> pos(-100.0, 100.0);\n    std::uniform_real_distribution<double> vel(-1.0, 1.0);\n    std::uniform_real_distribution<double> m(0.1, 10.0);\n    std::vector<Body> bodies(n);\n    for (int i = 0; i < n; ++i) {\n        bodies[i] = {pos(rng), pos(rng), pos(rng),\n                     vel(rng), vel(rng), vel(rng), m(rng)};\n    }\n    return bodies;\n}\n\nstatic void WriteJson(const std::string &path, const std::string &payload) {\n    if (path.empty()) { std::cout << payload << std::endl; return; }\n    std::ofstream out(path.c_str(), std::ios::binary);\n    out << payload;\n}\n\nint main(int argc, char **argv) {\n    std::string json_path;\n    int seed = 42;\n    int num_bodies = 1024;\n    int rounds = 20;\n\n    for (int i = 1; i < argc; ++i) {\n        std::string arg = argv[i];\n        if (arg == \"--json\" && i + 1 < argc) json_path = argv[++i];\n        else if (arg == \"--seed\" && i + 1 < argc) seed = std::atoi(argv[++i]);\n        else if (arg == \"--bodies\" && i + 1 < argc) num_bodies = std::atoi(argv[++i]);\n        else if (arg == \"--rounds\" && i + 1 < argc) rounds = std::atoi(argv[++i]);\n    }\n\n    std::mt19937 rng(seed);\n    auto bodies = GenerateBodies(rng, num_bodies);\n\n    // Correctness check\n    std::vector<double> ref_fx, ref_fy, ref_fz;\n    std::vector<double> fx, fy, fz;\n    ReferenceForces(bodies, ref_fx, ref_fy, ref_fz);\n    ComputeForces(bodies, fx, fy, fz);\n    for (int i = 0; i < num_bodies; ++i) {\n        double mag = std::abs(ref_fx[i]) + std::abs(ref_fy[i]) + std::abs(ref_fz[i]);\n        double err = std::abs(fx[i] - ref_fx[i]) + std::abs(fy[i] - ref_fy[i])\n                   + std::abs(fz[i] - ref_fz[i]);\n        // Relative tolerance: allow FP reordering from SIMD/SoA/tiling\n        double tol = std::max(1e-6, mag * 1e-6);\n        if (err > tol) {\n            std::cerr << \"force mismatch at body \" << i\n                      << \" err=\" << err << \" tol=\" << tol << std::endl;\n            return 2;\n        }\n    }\n\n    // Benchmark\n    std::vector<double> latencies;\n    latencies.reserve(rounds);\n    double total_time = 0.0;\n\n    for (int r = 0; r < rounds; ++r) {\n        auto t0 = std::chrono::high_resolution_clock::now();\n        ComputeForces(bodies, fx, fy, fz);\n        auto t1 = std::chrono::high_resolution_clock::now();\n        double dt = std::chrono::duration<double>(t1 - t0).count();\n        latencies.push_back(dt);\n        total_time += dt;\n    }\n\n    double ops_per_sec = rounds / total_time;\n    std::sort(latencies.begin(), latencies.end());\n    double p99 = latencies.empty() ? 0.0\n        : latencies[(size_t)(0.99 * (latencies.size() - 1))];\n\n    std::ostringstream os;\n    os.setf(std::ios::fixed);\n    os.precision(6);\n    os << \"{\\\"ops_per_sec\\\":\" << ops_per_sec\n       << \",\\\"p99_latency_us\\\":\" << (p99 * 1e6)\n       << \",\\\"num_bodies\\\":\" << num_bodies << \"}\";\n    WriteJson(json_path, os.str());\n    return 0;\n}\n```\nKey features: Alternative approach to combined_score, Alternative approach to error\n\n### Program D2 (Score: 0.0000)\n```cpp\n#include <algorithm>\n#include <chrono>\n#include <cmath>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n#include <random>\n#include <sstream>\n#include <string>\n#include <vector>\n\n// Array-of-Structures layout (deliberately naive for cache performance)\nstruct Body {\n    double x, y, z;\n    double vx, vy, vz;\n    double mass;\n};\n\n// Reference implementation (outside EVOLVE-BLOCK, used for correctness check)\nstatic void ReferenceForces(const std::vector<Body> &bodies,\n                            std::vector<double> &fx,\n                            std::vector<double> &fy,\n                            std::vector<double> &fz) {\n    int n = (int)bodies.size();\n    fx.assign(n, 0.0);\n    fy.assign(n, 0.0);\n    fz.assign(n, 0.0);\n    const double eps2 = 1e-9;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            double dx = bodies[j].x - bodies[i].x;\n            double dy = bodies[j].y - bodies[i].y;\n            double dz = bodies[j].z - bodies[i].z;\n            double r2 = dx * dx + dy * dy + dz * dz + eps2;\n            double inv_r = 1.0 / std::sqrt(r2);\n            double inv_r3 = inv_r * inv_r * inv_r;\n            double fi = bodies[j].mass * inv_r3;\n            double fj = bodies[i].mass * inv_r3;\n            fx[i] += dx * fi; fy[i] += dy * fi; fz[i] += dz * fi;\n            fx[j] -= dx * fj; fy[j] -= dy * fj; fz[j] -= dz * fj;\n        }\n    }\n}\n\n// EVOLVE-BLOCK-START\n\nstatic void ComputeForces(const std::vector<Body> &bodies,\n                          std::vector<double> &fx,\n                          std::vector<double> &fy,\n                          std::vector<double> &fz) {\n    int n = (int)bodies.size();\n    fx.assign(n, 0.0);\n    fy.assign(n, 0.0);\n    fz.assign(n, 0.0);\n    const double eps2 = 1e-9;\n    \n    // Optimized loop with reduced memory accesses and better instruction scheduling\n    for (int i = 0; i < n; ++i) {\n        const Body& bi = bodies[i];\n        const double xi = bi.x;\n        const double yi = bi.y;\n        const double zi = bi.z;\n        const double mi = bi.mass;\n        \n        for (int j = i + 1; j < n; ++j) {\n            const Body& bj = bodies[j];\n            double dx = bj.x - xi;\n            double dy = bj.y - yi;\n            double dz = bj.z - zi;\n            double r2 = dx * dx + dy * dy + dz * dz + eps2;\n            \n            // Single reciprocal square root call for better performance\n            double inv_r = 1.0 / std::sqrt(r2);\n            double inv_r3 = inv_r * inv_r * inv_r;\n            \n            // Precompute force magnitudes to avoid redundant multiplications\n            double force_mag_j = bj.mass * inv_r3;\n            double force_mag_i = mi * inv_r3;\n            \n            // Apply forces to both bodies - reordered for better instruction scheduling\n            fx[i] += dx * force_mag_i;\n            fy[i] += dy * force_mag_i;\n            fz[i] += dz * force_mag_i;\n            \n            fx[j] -= dx * force_mag_j;\n            fy[j] -= dy * force_mag_j;\n            fz[j] -= dz * force_mag_j;\n        }\n    }\n}\n\n// EVOLVE-BLOCK-END\n\nstatic std::vector<Body> GenerateBodies(std::mt19937 &rng, int n) {\n    std::uniform_real_distribution<double> pos(-100.0, 100.0);\n    std::uniform_real_distribution<double> vel(-1.0, 1.0);\n    std::uniform_real_distribution<double> m(0.1, 10.0);\n    std::vector<Body> bodies(n);\n    for (int i = 0; i < n; ++i) {\n        bodies[i] = {pos(rng), pos(rng), pos(rng),\n                     vel(rng), vel(rng), vel(rng), m(rng)};\n    }\n    return bodies;\n}\n\nstatic void WriteJson(const std::string &path, const std::string &payload) {\n    if (path.empty()) { std::cout << payload << std::endl; return; }\n    std::ofstream out(path.c_str(), std::ios::binary);\n    out << payload;\n}\n\nint main(int argc, char **argv) {\n    std::string json_path;\n    int seed = 42;\n    int num_bodies = 1024;\n    int rounds = 20;\n\n    for (int i = 1; i < argc; ++i) {\n        std::string arg = argv[i];\n        if (arg == \"--json\" && i + 1 < argc) json_path = argv[++i];\n        else if (arg == \"--seed\" && i + 1 < argc) seed = std::atoi(argv[++i]);\n        else if (arg == \"--bodies\" && i + 1 < argc) num_bodies = std::atoi(argv[++i]);\n        else if (arg == \"--rounds\" && i + 1 < argc) rounds = std::atoi(argv[++i]);\n    }\n\n    std::mt19937 rng(seed);\n    auto bodies = GenerateBodies(rng, num_bodies);\n\n    // Correctness check\n    std::vector<double> ref_fx, ref_fy, ref_fz;\n    std::vector<double> fx, fy, fz;\n    ReferenceForces(bodies, ref_fx, ref_fy, ref_fz);\n    ComputeForces(bodies, fx, fy, fz);\n    for (int i = 0; i < num_bodies; ++i) {\n        double mag = std::abs(ref_fx[i]) + std::abs(ref_fy[i]) + std::abs(ref_fz[i]);\n        double err = std::abs(fx[i] - ref_fx[i]) + std::abs(fy[i] - ref_fy[i])\n                   + std::abs(fz[i] - ref_fz[i]);\n        // Relative tolerance: allow FP reordering from SIMD/SoA/tiling\n        double tol = std::max(1e-6, mag * 1e-6);\n        if (err > tol) {\n            std::cerr << \"force mismatch at body \" << i\n                      << \" err=\" << err << \" tol=\" << tol << std::endl;\n            return 2;\n        }\n    }\n\n    // Benchmark\n    std::vector<double> latencies;\n    latencies.reserve(rounds);\n    double total_time = 0.0;\n\n    for (int r = 0; r < rounds; ++r) {\n        auto t0 = std::chrono::high_resolution_clock::now();\n        ComputeForces(bodies, fx, fy, fz);\n        auto t1 = std::chrono::high_resolution_clock::now();\n        double dt = std::chrono::duration<double>(t1 - t0).count();\n        latencies.push_back(dt);\n        total_time += dt;\n    }\n\n    double ops_per_sec = rounds / total_time;\n    std::sort(latencies.begin(), latencies.end());\n    double p99 = latencies.empty() ? 0.0\n        : latencies[(size_t)(0.99 * (latencies.size() - 1))];\n\n    std::ostringstream os;\n    os.setf(std::ios::fixed);\n    os.precision(6);\n    os << \"{\\\"ops_per_sec\\\":\" << ops_per_sec\n       << \",\\\"p99_latency_us\\\":\" << (p99 * 1e6)\n       << \",\\\"num_bodies\\\":\" << num_bodies << \"}\";\n    WriteJson(json_path, os.str());\n    return 0;\n}\n```\nKey features: Alternative approach to combined_score, Alternative approach to error\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.0000, Type: Exploratory)\n```cpp\n#include <algorithm>\n#include <chrono>\n#include <cmath>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n#include <random>\n#include <sstream>\n#include <string>\n#include <vector>\n\n// Array-of-Structures layout (deliberately naive for cache performance)\nstruct Body {\n    double x, y, z;\n    double vx, vy, vz;\n    double mass;\n};\n\n// Reference implementation (outside EVOLVE-BLOCK, used for correctness check)\nstatic void ReferenceForces(const std::vector<Body> &bodies,\n                            std::vector<double> &fx,\n                            std::vector<double> &fy,\n                            std::vector<double> &fz) {\n    int n = (int)bodies.size();\n    fx.assign(n, 0.0);\n    fy.assign(n, 0.0);\n    fz.assign(n, 0.0);\n    const double eps2 = 1e-9;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            double dx = bodies[j].x - bodies[i].x;\n            double dy = bodies[j].y - bodies[i].y;\n            double dz = bodies[j].z - bodies[i].z;\n            double r2 = dx * dx + dy * dy + dz * dz + eps2;\n            double inv_r = 1.0 / std::sqrt(r2);\n            double inv_r3 = inv_r * inv_r * inv_r;\n            double fi = bodies[j].mass * inv_r3;\n            double fj = bodies[i].mass * inv_r3;\n            fx[i] += dx * fi; fy[i] += dy * fi; fz[i] += dz * fi;\n            fx[j] -= dx * fj; fy[j] -= dy * fj; fz[j] -= dz * fj;\n        }\n    }\n}\n\n// EVOLVE-BLOCK-START\n\nstatic void ComputeForces(const std::vector<Body> &bodies,\n                          std::vector<double> &fx,\n                          std::vector<double> &fy,\n                          std::vector<double> &fz) {\n    int n = (int)bodies.size();\n    fx.assign(n, 0.0);\n    fy.assign(n, 0.0);\n    fz.assign(n, 0.0);\n    const double eps2 = 1e-9;\n    \n    // Loop over pairs with manual unrolling for better performance\n    for (int i = 0; i < n; ++i) {\n        const Body& bi = bodies[i];\n        const double xi = bi.x;\n        const double yi = bi.y;\n        const double zi = bi.z;\n        const double mi = bi.mass;\n        \n        // Process pairs in chunks of 2 to reduce loop overhead\n        int j = i + 1;\n        for (; j + 1 < n; j += 2) {\n            // Process two pairs simultaneously\n            const Body& bj1 = bodies[j];\n            const Body& bj2 = bodies[j + 1];\n            \n            // First pair (i, j)\n            double dx1 = bj1.x - xi;\n            double dy1 = bj1.y - yi;\n            double dz1 = bj1.z - zi;\n            double r2_1 = dx1 * dx1 + dy1 * dy1 + dz1 * dz1 + eps2;\n            double inv_r1 = 1.0 / std::sqrt(r2_1);\n            double inv_r3_1 = inv_r1 * inv_r1 * inv_r1;\n            double force_mag1 = bj1.mass * inv_r3_1;\n            double force_i1 = force_mag1 * mi;\n            \n            fx[i] += dx1 * force_i1;\n            fy[i] += dy1 * force_i1;\n            fz[i] += dz1 * force_i1;\n            \n            fx[j] -= dx1 * force_mag1;\n            fy[j] -= dy1 * force_mag1;\n            fz[j] -= dz1 * force_mag1;\n            \n            // Second pair (i, j+1)\n            double dx2 = bj2.x - xi;\n            double dy2 = bj2.y - yi;\n            double dz2 = bj2.z - zi;\n            double r2_2 = dx2 * dx2 + dy2 * dy2 + dz2 * dz2 + eps2;\n            double inv_r2 = 1.0 / std::sqrt(r2_2);\n            double inv_r3_2 = inv_r2 * inv_r2 * inv_r2;\n            double force_mag2 = bj2.mass * inv_r3_2;\n            double force_i2 = force_mag2 * mi;\n            \n            fx[i] += dx2 * force_i2;\n            fy[i] += dy2 * force_i2;\n            fz[i] += dz2 * force_i2;\n            \n            fx[j + 1] -= dx2 * force_mag2;\n            fy[j + 1] -= dy2 * force_mag2;\n            fz[j + 1] -= dz2 * force_mag2;\n        }\n        \n        // Handle remaining pair if odd number\n        for (; j < n; ++j) {\n            const Body& bj = bodies[j];\n            double dx = bj.x - xi;\n            double dy = bj.y - yi;\n            double dz = bj.z - zi;\n            double r2 = dx * dx + dy * dy + dz * dz + eps2;\n            double inv_r = 1.0 / std::sqrt(r2);\n            double inv_r3 = inv_r * inv_r * inv_r;\n            double force_mag = bj.mass * inv_r3;\n            double force_i = force_mag * mi;\n            \n            fx[i] += dx * force_i;\n            fy[i] += dy * force_i;\n            fz[i] += dz * force_i;\n            \n            fx[j] -= dx * force_mag;\n            fy[j] -= dy * force_mag;\n            fz[j] -= dz * force_mag;\n        }\n    }\n}\n\n// EVOLVE-BLOCK-END\n\nstatic std::vector<Body> GenerateBodies(std::mt19937 &rng, int n) {\n    std::uniform_real_distribution<double> pos(-100.0, 100.0);\n    std::uniform_real_distribution<double> vel(-1.0, 1.0);\n    std::uniform_real_distribution<double> m(0.1, 10.0);\n    std::vector<Body> bodies(n);\n    for (int i = 0; i < n; ++i) {\n        bodies[i] = {pos(rng), pos(rng), pos(rng),\n                     vel(rng), vel(rng), vel(rng), m(rng)};\n    }\n    return bodies;\n}\n\nstatic void WriteJson(const std::string &path, const std::string &payload) {\n    if (path.empty()) { std::cout << payload << std::endl; return; }\n    std::ofstream out(path.c_str(), std::ios::binary);\n    out << payload;\n}\n\nint main(int argc, char **argv) {\n    std::string json_path;\n    int seed = 42;\n    int num_bodies = 1024;\n    int rounds = 20;\n\n    for (int i = 1; i < argc; ++i) {\n        std::string arg = argv[i];\n        if (arg == \"--json\" && i + 1 < argc) json_path = argv[++i];\n        else if (arg == \"--seed\" && i + 1 < argc) seed = std::atoi(argv[++i]);\n        else if (arg == \"--bodies\" && i + 1 < argc) num_bodies = std::atoi(argv[++i]);\n        else if (arg == \"--rounds\" && i + 1 < argc) rounds = std::atoi(argv[++i]);\n    }\n\n    std::mt19937 rng(seed);\n    auto bodies = GenerateBodies(rng, num_bodies);\n\n    // Correctness check\n    std::vector<double> ref_fx, ref_fy, ref_fz;\n    std::vector<double> fx, fy, fz;\n    ReferenceForces(bodies, ref_fx, ref_fy, ref_fz);\n    ComputeForces(bodies, fx, fy, fz);\n    for (int i = 0; i < num_bodies; ++i) {\n        double mag = std::abs(ref_fx[i]) + std::abs(ref_fy[i]) + std::abs(ref_fz[i]);\n        double err = std::abs(fx[i] - ref_fx[i]) + std::abs(fy[i] - ref_fy[i])\n                   + std::abs(fz[i] - ref_fz[i]);\n        // Relative tolerance: allow FP reordering from SIMD/SoA/tiling\n        double tol = std::max(1e-6, mag * 1e-6);\n        if (err > tol) {\n            std::cerr << \"force mismatch at body \" << i\n                      << \" err=\" << err << \" tol=\" << tol << std::endl;\n            return 2;\n        }\n    }\n\n    // Benchmark\n    std::vector<double> latencies;\n    latencies.reserve(rounds);\n    double total_time = 0.0;\n\n    for (int r = 0; r < rounds; ++r) {\n        auto t0 = std::chrono::high_resolution_clock::now();\n        ComputeForces(bodies, fx, fy, fz);\n        auto t1 = std::chrono::high_resolution_clock::now();\n        double dt = std::chrono::duration<double>(t1 - t0).count();\n        latencies.push_back(dt);\n        total_time += dt;\n    }\n\n    double ops_per_sec = rounds / total_time;\n    std::sort(latencies.begin(), latencies.end());\n    double p99 = latencies.empty() ? 0.0\n        : latencies[(size_t)(0.99 * (latencies.size() - 1))];\n\n    std::ostringstream os;\n    os.setf(std::ios::fixed);\n    os.precision(6);\n    os << \"{\\\"ops_per_sec\\\":\" << ops_per_sec\n       << \",\\\"p99_latency_us\\\":\" << (p99 * 1e6)\n       << \",\\\"num_bodies\\\":\" << num_bodies << \"}\";\n    WriteJson(json_path, os.str());\n    return 0;\n}\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 1.4086, Type: High-Performer)\n```cpp\n#include <algorithm>\n#include <chrono>\n#include <cmath>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n#include <random>\n#include <sstream>\n#include <string>\n#include <vector>\n\n// Array-of-Structures layout (deliberately naive for cache performance)\nstruct Body {\n    double x, y, z;\n    double vx, vy, vz;\n    double mass;\n};\n\n// Reference implementation (outside EVOLVE-BLOCK, used for correctness check)\nstatic void ReferenceForces(const std::vector<Body> &bodies,\n                            std::vector<double> &fx,\n                            std::vector<double> &fy,\n                            std::vector<double> &fz) {\n    int n = (int)bodies.size();\n    fx.assign(n, 0.0);\n    fy.assign(n, 0.0);\n    fz.assign(n, 0.0);\n    const double eps2 = 1e-9;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            double dx = bodies[j].x - bodies[i].x;\n            double dy = bodies[j].y - bodies[i].y;\n            double dz = bodies[j].z - bodies[i].z;\n            double r2 = dx * dx + dy * dy + dz * dz + eps2;\n            double inv_r = 1.0 / std::sqrt(r2);\n            double inv_r3 = inv_r * inv_r * inv_r;\n            double fi = bodies[j].mass * inv_r3;\n            double fj = bodies[i].mass * inv_r3;\n            fx[i] += dx * fi; fy[i] += dy * fi; fz[i] += dz * fi;\n            fx[j] -= dx * fj; fy[j] -= dy * fj; fz[j] -= dz * fj;\n        }\n    }\n}\n\n// EVOLVE-BLOCK-START\n\nstatic void ComputeForces(const std::vector<Body> &bodies,\n                          std::vector<double> &fx,\n                          std::vector<double> &fy,\n                          std::vector<double> &fz) {\n    int n = (int)bodies.size();\n    fx.assign(n, 0.0);\n    fy.assign(n, 0.0);\n    fz.assign(n, 0.0);\n    const double eps2 = 1e-9;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            double dx = bodies[j].x - bodies[i].x;\n            double dy = bodies[j].y - bodies[i].y;\n            double dz = bodies[j].z - bodies[i].z;\n            double r2 = dx * dx + dy * dy + dz * dz + eps2;\n            double inv_r = 1.0 / std::sqrt(r2);\n            double inv_r3 = inv_r * inv_r * inv_r;\n            double fi = bodies[j].mass * inv_r3;\n            double fj = bodies[i].mass * inv_r3;\n            fx[i] += dx * fi; fy[i] += dy * fi; fz[i] += dz * fi;\n            fx[j] -= dx * fj; fy[j] -= dy * fj; fz[j] -= dz * fj;\n        }\n    }\n}\n\n// EVOLVE-BLOCK-END\n\nstatic std::vector<Body> GenerateBodies(std::mt19937 &rng, int n) {\n    std::uniform_real_distribution<double> pos(-100.0, 100.0);\n    std::uniform_real_distribution<double> vel(-1.0, 1.0);\n    std::uniform_real_distribution<double> m(0.1, 10.0);\n    std::vector<Body> bodies(n);\n    for (int i = 0; i < n; ++i) {\n        bodies[i] = {pos(rng), pos(rng), pos(rng),\n                     vel(rng), vel(rng), vel(rng), m(rng)};\n    }\n    return bodies;\n}\n\nstatic void WriteJson(const std::string &path, const std::string &payload) {\n    if (path.empty()) { std::cout << payload << std::endl; return; }\n    std::ofstream out(path.c_str(), std::ios::binary);\n    out << payload;\n}\n\nint main(int argc, char **argv) {\n    std::string json_path;\n    int seed = 42;\n    int num_bodies = 1024;\n    int rounds = 20;\n\n    for (int i = 1; i < argc; ++i) {\n        std::string arg = argv[i];\n        if (arg == \"--json\" && i + 1 < argc) json_path = argv[++i];\n        else if (arg == \"--seed\" && i + 1 < argc) seed = std::atoi(argv[++i]);\n        else if (arg == \"--bodies\" && i + 1 < argc) num_bodies = std::atoi(argv[++i]);\n        else if (arg == \"--rounds\" && i + 1 < argc) rounds = std::atoi(argv[++i]);\n    }\n\n    std::mt19937 rng(seed);\n    auto bodies = GenerateBodies(rng, num_bodies);\n\n    // Correctness check\n    std::vector<double> ref_fx, ref_fy, ref_fz;\n    std::vector<double> fx, fy, fz;\n    ReferenceForces(bodies, ref_fx, ref_fy, ref_fz);\n    ComputeForces(bodies, fx, fy, fz);\n    for (int i = 0; i < num_bodies; ++i) {\n        double mag = std::abs(ref_fx[i]) + std::abs(ref_fy[i]) + std::abs(ref_fz[i]);\n        double err = std::abs(fx[i] - ref_fx[i]) + std::abs(fy[i] - ref_fy[i])\n                   + std::abs(fz[i] - ref_fz[i]);\n        // Relative tolerance: allow FP reordering from SIMD/SoA/tiling\n        double tol = std::max(1e-6, mag * 1e-6);\n        if (err > tol) {\n            std::cerr << \"force mismatch at body \" << i\n                      << \" err=\" << err << \" tol=\" << tol << std::endl;\n            return 2;\n        }\n    }\n\n    // Benchmark\n    std::vector<double> latencies;\n    latencies.reserve(rounds);\n    double total_time = 0.0;\n\n    for (int r = 0; r < rounds; ++r) {\n        auto t0 = std::chrono::high_resolution_clock::now();\n        ComputeForces(bodies, fx, fy, fz);\n        auto t1 = std::chrono::high_resolution_clock::now();\n        double dt = std::chrono::duration<double>(t1 - t0).count();\n        latencies.push_back(dt);\n        total_time += dt;\n    }\n\n    double ops_per_sec = rounds / total_time;\n    std::sort(latencies.begin(), latencies.end());\n    double p99 = latencies.empty() ? 0.0\n        : latencies[(size_t)(0.99 * (latencies.size() - 1))];\n\n    std::ostringstream os;\n    os.setf(std::ios::fixed);\n    os.precision(6);\n    os << \"{\\\"ops_per_sec\\\":\" << ops_per_sec\n       << \",\\\"p99_latency_us\\\":\" << (p99 * 1e6)\n       << \",\\\"num_bodies\\\":\" << num_bodies << \"}\";\n    WriteJson(json_path, os.str());\n    return 0;\n}\n\n```\nUnique approach: [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 3 (Score: 0.0000, Type: Exploratory)\n```cpp\n#include <algorithm>\n#include <chrono>\n#include <cmath>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n#include <random>\n#include <sstream>\n#include <string>\n#include <vector>\n\n// Array-of-Structures layout (deliberately naive for cache performance)\nstruct Body {\n    double x, y, z;\n    double vx, vy, vz;\n    double mass;\n};\n\n// Reference implementation (outside EVOLVE-BLOCK, used for correctness check)\nstatic void ReferenceForces(const std::vector<Body> &bodies,\n                            std::vector<double> &fx,\n                            std::vector<double> &fy,\n                            std::vector<double> &fz) {\n    int n = (int)bodies.size();\n    fx.assign(n, 0.0);\n    fy.assign(n, 0.0);\n    fz.assign(n, 0.0);\n    const double eps2 = 1e-9;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            double dx = bodies[j].x - bodies[i].x;\n            double dy = bodies[j].y - bodies[i].y;\n            double dz = bodies[j].z - bodies[i].z;\n            double r2 = dx * dx + dy * dy + dz * dz + eps2;\n            double inv_r = 1.0 / std::sqrt(r2);\n            double inv_r3 = inv_r * inv_r * inv_r;\n            double fi = bodies[j].mass * inv_r3;\n            double fj = bodies[i].mass * inv_r3;\n            fx[i] += dx * fi; fy[i] += dy * fi; fz[i] += dz * fi;\n            fx[j] -= dx * fj; fy[j] -= dy * fj; fz[j] -= dz * fj;\n        }\n    }\n}\n\n// EVOLVE-BLOCK-START\n\nstatic void ComputeForces(const std::vector<Body> &bodies,\n                          std::vector<double> &fx,\n                          std::vector<double> &fy,\n                          std::vector<double> &fz) {\n    int n = (int)bodies.size();\n    fx.assign(n, 0.0);\n    fy.assign(n, 0.0);\n    fz.assign(n, 0.0);\n    const double eps2 = 1e-9;\n    \n    // Optimized loop with reduced operations and better instruction scheduling\n    for (int i = 0; i < n; ++i) {\n        const Body& bi = bodies[i];\n        const double xi = bi.x;\n        const double yi = bi.y;\n        const double zi = bi.z;\n        const double mi = bi.mass;\n        \n        for (int j = i + 1; j < n; ++j) {\n            const Body& bj = bodies[j];\n            double dx = bj.x - xi;\n            double dy = bj.y - yi;\n            double dz = bj.z - zi;\n            double r2 = dx * dx + dy * dy + dz * dz + eps2;\n            \n            // Compute inverse sqrt once and reuse\n            double inv_r = 1.0 / std::sqrt(r2);\n            double inv_r3 = inv_r * inv_r * inv_r;\n            \n            // Precompute force magnitudes to avoid redundant multiplications\n            double force_mag_j = bj.mass * inv_r3;\n            double force_mag_i = mi * inv_r3;\n            \n            // Apply forces to both bodies - reordered for better instruction scheduling\n            fx[i] += dx * force_mag_i;\n            fy[i] += dy * force_mag_i;\n            fz[i] += dz * force_mag_i;\n            \n            fx[j] -= dx * force_mag_j;\n            fy[j] -= dy * force_mag_j;\n            fz[j] -= dz * force_mag_j;\n        }\n    }\n}\n\n// EVOLVE-BLOCK-END\n\nstatic std::vector<Body> GenerateBodies(std::mt19937 &rng, int n) {\n    std::uniform_real_distribution<double> pos(-100.0, 100.0);\n    std::uniform_real_distribution<double> vel(-1.0, 1.0);\n    std::uniform_real_distribution<double> m(0.1, 10.0);\n    std::vector<Body> bodies(n);\n    for (int i = 0; i < n; ++i) {\n        bodies[i] = {pos(rng), pos(rng), pos(rng),\n                     vel(rng), vel(rng), vel(rng), m(rng)};\n    }\n    return bodies;\n}\n\nstatic void WriteJson(const std::string &path, const std::string &payload) {\n    if (path.empty()) { std::cout << payload << std::endl; return; }\n    std::ofstream out(path.c_str(), std::ios::binary);\n    out << payload;\n}\n\nint main(int argc, char **argv) {\n    std::string json_path;\n    int seed = 42;\n    int num_bodies = 1024;\n    int rounds = 20;\n\n    for (int i = 1; i < argc; ++i) {\n        std::string arg = argv[i];\n        if (arg == \"--json\" && i + 1 < argc) json_path = argv[++i];\n        else if (arg == \"--seed\" && i + 1 < argc) seed = std::atoi(argv[++i]);\n        else if (arg == \"--bodies\" && i + 1 < argc) num_bodies = std::atoi(argv[++i]);\n        else if (arg == \"--rounds\" && i + 1 < argc) rounds = std::atoi(argv[++i]);\n    }\n\n    std::mt19937 rng(seed);\n    auto bodies = GenerateBodies(rng, num_bodies);\n\n    // Correctness check\n    std::vector<double> ref_fx, ref_fy, ref_fz;\n    std::vector<double> fx, fy, fz;\n    ReferenceForces(bodies, ref_fx, ref_fy, ref_fz);\n    ComputeForces(bodies, fx, fy, fz);\n    for (int i = 0; i < num_bodies; ++i) {\n        double mag = std::abs(ref_fx[i]) + std::abs(ref_fy[i]) + std::abs(ref_fz[i]);\n        double err = std::abs(fx[i] - ref_fx[i]) + std::abs(fy[i] - ref_fy[i])\n                   + std::abs(fz[i] - ref_fz[i]);\n        // Relative tolerance: allow FP reordering from SIMD/SoA/tiling\n        double tol = std::max(1e-6, mag * 1e-6);\n        if (err > tol) {\n            std::cerr << \"force mismatch at body \" << i\n                      << \" err=\" << err << \" tol=\" << tol << std::endl;\n            return 2;\n        }\n    }\n\n    // Benchmark\n    std::vector<double> latencies;\n    latencies.reserve(rounds);\n    double total_time = 0.0;\n\n    for (int r = 0; r < rounds; ++r) {\n        auto t0 = std::chrono::high_resolution_clock::now();\n        ComputeForces(bodies, fx, fy, fz);\n        auto t1 = std::chrono::high_resolution_clock::now();\n        double dt = std::chrono::duration<double>(t1 - t0).count();\n        latencies.push_back(dt);\n        total_time += dt;\n    }\n\n    double ops_per_sec = rounds / total_time;\n    std::sort(latencies.begin(), latencies.end());\n    double p99 = latencies.empty() ? 0.0\n        : latencies[(size_t)(0.99 * (latencies.size() - 1))];\n\n    std::ostringstream os;\n    os.setf(std::ios::fixed);\n    os.precision(6);\n    os << \"{\\\"ops_per_sec\\\":\" << ops_per_sec\n       << \",\\\"p99_latency_us\\\":\" << (p99 * 1e6)\n       << \",\\\"num_bodies\\\":\" << num_bodies << \"}\";\n    WriteJson(json_path, os.str());\n    return 0;\n}\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```cpp\n#include <algorithm>\n#include <chrono>\n#include <cmath>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n#include <random>\n#include <sstream>\n#include <string>\n#include <vector>\n\n// Array-of-Structures layout (deliberately naive for cache performance)\nstruct Body {\n    double x, y, z;\n    double vx, vy, vz;\n    double mass;\n};\n\n// Reference implementation (outside EVOLVE-BLOCK, used for correctness check)\nstatic void ReferenceForces(const std::vector<Body> &bodies,\n                            std::vector<double> &fx,\n                            std::vector<double> &fy,\n                            std::vector<double> &fz) {\n    int n = (int)bodies.size();\n    fx.assign(n, 0.0);\n    fy.assign(n, 0.0);\n    fz.assign(n, 0.0);\n    const double eps2 = 1e-9;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            double dx = bodies[j].x - bodies[i].x;\n            double dy = bodies[j].y - bodies[i].y;\n            double dz = bodies[j].z - bodies[i].z;\n            double r2 = dx * dx + dy * dy + dz * dz + eps2;\n            double inv_r = 1.0 / std::sqrt(r2);\n            double inv_r3 = inv_r * inv_r * inv_r;\n            double fi = bodies[j].mass * inv_r3;\n            double fj = bodies[i].mass * inv_r3;\n            fx[i] += dx * fi; fy[i] += dy * fi; fz[i] += dz * fi;\n            fx[j] -= dx * fj; fy[j] -= dy * fj; fz[j] -= dz * fj;\n        }\n    }\n}\n\n// EVOLVE-BLOCK-START\n\nstatic void ComputeForces(const std::vector<Body> &bodies,\n                          std::vector<double> &fx,\n                          std::vector<double> &fy,\n                          std::vector<double> &fz) {\n    int n = (int)bodies.size();\n    fx.assign(n, 0.0);\n    fy.assign(n, 0.0);\n    fz.assign(n, 0.0);\n    const double eps2 = 1e-9;\n    \n    // Loop unrolling and manual vectorization for better performance\n    for (int i = 0; i < n; ++i) {\n        const Body& bi = bodies[i];\n        for (int j = i + 1; j < n; ++j) {\n            const Body& bj = bodies[j];\n            double dx = bj.x - bi.x;\n            double dy = bj.y - bi.y;\n            double dz = bj.z - bi.z;\n            double r2 = dx * dx + dy * dy + dz * dz + eps2;\n            \n            // Use fast reciprocal square root approximation\n            double inv_r = 1.0 / std::sqrt(r2);\n            double inv_r3 = inv_r * inv_r * inv_r;\n            \n            double fi = bj.mass * inv_r3;\n            double fj = bi.mass * inv_r3;\n            \n            fx[i] += dx * fi;\n            fy[i] += dy * fi;\n            fz[i] += dz * fi;\n            \n            fx[j] -= dx * fj;\n            fy[j] -= dy * fj;\n            fz[j] -= dz * fj;\n        }\n    }\n}\n\n// EVOLVE-BLOCK-END\n\nstatic std::vector<Body> GenerateBodies(std::mt19937 &rng, int n) {\n    std::uniform_real_distribution<double> pos(-100.0, 100.0);\n    std::uniform_real_distribution<double> vel(-1.0, 1.0);\n    std::uniform_real_distribution<double> m(0.1, 10.0);\n    std::vector<Body> bodies(n);\n    for (int i = 0; i < n; ++i) {\n        bodies[i] = {pos(rng), pos(rng), pos(rng),\n                     vel(rng), vel(rng), vel(rng), m(rng)};\n    }\n    return bodies;\n}\n\nstatic void WriteJson(const std::string &path, const std::string &payload) {\n    if (path.empty()) { std::cout << payload << std::endl; return; }\n    std::ofstream out(path.c_str(), std::ios::binary);\n    out << payload;\n}\n\nint main(int argc, char **argv) {\n    std::string json_path;\n    int seed = 42;\n    int num_bodies = 1024;\n    int rounds = 20;\n\n    for (int i = 1; i < argc; ++i) {\n        std::string arg = argv[i];\n        if (arg == \"--json\" && i + 1 < argc) json_path = argv[++i];\n        else if (arg == \"--seed\" && i + 1 < argc) seed = std::atoi(argv[++i]);\n        else if (arg == \"--bodies\" && i + 1 < argc) num_bodies = std::atoi(argv[++i]);\n        else if (arg == \"--rounds\" && i + 1 < argc) rounds = std::atoi(argv[++i]);\n    }\n\n    std::mt19937 rng(seed);\n    auto bodies = GenerateBodies(rng, num_bodies);\n\n    // Correctness check\n    std::vector<double> ref_fx, ref_fy, ref_fz;\n    std::vector<double> fx, fy, fz;\n    ReferenceForces(bodies, ref_fx, ref_fy, ref_fz);\n    ComputeForces(bodies, fx, fy, fz);\n    for (int i = 0; i < num_bodies; ++i) {\n        double mag = std::abs(ref_fx[i]) + std::abs(ref_fy[i]) + std::abs(ref_fz[i]);\n        double err = std::abs(fx[i] - ref_fx[i]) + std::abs(fy[i] - ref_fy[i])\n                   + std::abs(fz[i] - ref_fz[i]);\n        // Relative tolerance: allow FP reordering from SIMD/SoA/tiling\n        double tol = std::max(1e-6, mag * 1e-6);\n        if (err > tol) {\n            std::cerr << \"force mismatch at body \" << i\n                      << \" err=\" << err << \" tol=\" << tol << std::endl;\n            return 2;\n        }\n    }\n\n    // Benchmark\n    std::vector<double> latencies;\n    latencies.reserve(rounds);\n    double total_time = 0.0;\n\n    for (int r = 0; r < rounds; ++r) {\n        auto t0 = std::chrono::high_resolution_clock::now();\n        ComputeForces(bodies, fx, fy, fz);\n        auto t1 = std::chrono::high_resolution_clock::now();\n        double dt = std::chrono::duration<double>(t1 - t0).count();\n        latencies.push_back(dt);\n        total_time += dt;\n    }\n\n    double ops_per_sec = rounds / total_time;\n    std::sort(latencies.begin(), latencies.end());\n    double p99 = latencies.empty() ? 0.0\n        : latencies[(size_t)(0.99 * (latencies.size() - 1))];\n\n    std::ostringstream os;\n    os.setf(std::ios::fixed);\n    os.precision(6);\n    os << \"{\\\"ops_per_sec\\\":\" << ops_per_sec\n       << \",\\\"p99_latency_us\\\":\" << (p99 * 1e6)\n       << \",\\\"num_bodies\\\":\" << num_bodies << \"}\";\n    WriteJson(json_path, os.str());\n    return 0;\n}\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: ops_per_sec, p99_latency_us\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```cpp\n# Your rewritten program here\n```", "responses": ["Looking at the requirements and analyzing the current code, I need to optimize the N-body force computation inside the EVOLVE-BLOCK while maintaining correctness and improving performance.\n\nKey optimizations I can make:\n1. Reduce redundant calculations by caching intermediate values\n2. Improve instruction scheduling and memory access patterns\n3. Minimize function calls and use more efficient math operations\n4. Maintain the exact same interface and behavior\n\nHere's my optimized version:\n\n```cpp\n#include <algorithm>\n#include <chrono>\n#include <cmath>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n#include <random>\n#include <sstream>\n#include <string>\n#include <vector>\n\n// Array-of-Structures layout (deliberately naive for cache performance)\nstruct Body {\n    double x, y, z;\n    double vx, vy, vz;\n    double mass;\n};\n\n// Reference implementation (outside EVOLVE-BLOCK, used for correctness check)\nstatic void ReferenceForces(const std::vector<Body> &bodies,\n                            std::vector<double> &fx,\n                            std::vector<double> &fy,\n                            std::vector<double> &fz) {\n    int n = (int)bodies.size();\n    fx.assign(n, 0.0);\n    fy.assign(n, 0.0);\n    fz.assign(n, 0.0);\n    const double eps2 = 1e-9;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            double dx = bodies[j].x - bodies[i].x;\n            double dy = bodies[j].y - bodies[i].y;\n            double dz = bodies[j].z - bodies[i].z;\n            double r2 = dx * dx + dy * dy + dz * dz + eps2;\n            double inv_r = 1.0 / std::sqrt(r2);\n            double inv_r3 = inv_r * inv_r * inv_r;\n            double fi = bodies[j].mass * inv_r3;\n            double fj = bodies[i].mass * inv_r3;\n            fx[i] += dx * fi; fy[i] += dy * fi; fz[i] += dz * fi;\n            fx[j] -= dx * fj; fy[j] -= dy * fj; fz[j] -= dz * fj;\n        }\n    }\n}\n\n// EVOLVE-BLOCK-START\n\nstatic void ComputeForces(const std::vector<Body> &bodies,\n                          std::vector<double> &fx,\n                          std::vector<double> &fy,\n                          std::vector<double> &fz) {\n    int n = (int)bodies.size();\n    fx.assign(n, 0.0);\n    fy.assign(n, 0.0);\n    fz.assign(n, 0.0);\n    const double eps2 = 1e-9;\n    \n    // Optimized loop with reduced operations and better instruction scheduling\n    for (int i = 0; i < n; ++i) {\n        const Body& bi = bodies[i];\n        const double xi = bi.x;\n        const double yi = bi.y;\n        const double zi = bi.z;\n        const double mi = bi.mass;\n        \n        for (int j = i + 1; j < n; ++j) {\n            const Body& bj = bodies[j];\n            double dx = bj.x - xi;\n            double dy = bj.y - yi;\n            double dz = bj.z - zi;\n            double r2 = dx * dx + dy * dy + dz * dz + eps2;\n            \n            // Compute inverse sqrt once and reuse\n            double inv_r = 1.0 / std::sqrt(r2);\n            double inv_r3 = inv_r * inv_r * inv_r;\n            \n            // Precompute force magnitudes to avoid redundant multiplications\n            double force_mag_j = bj.mass * inv_r3;\n            double force_mag_i = mi * inv_r3;\n            \n            // Apply forces to both bodies - reordered for better instruction scheduling\n            fx[i] += dx * force_mag_i;\n            fy[i] += dy * force_mag_i;\n            fz[i] += dz * force_mag_i;\n            \n            fx[j] -= dx * force_mag_j;\n            fy[j] -= dy * force_mag_j;\n            fz[j] -= dz * force_mag_j;\n        }\n    }\n}\n\n// EVOLVE-BLOCK-END\n\nstatic std::vector<Body> GenerateBodies(std::mt19937 &rng, int n) {\n    std::uniform_real_distribution<double> pos(-100.0, 100.0);\n    std::uniform_real_distribution<double> vel(-1.0, 1.0);\n    std::uniform_real_distribution<double> m(0.1, 10.0);\n    std::vector<Body> bodies(n);\n    for (int i = 0; i < n; ++i) {\n        bodies[i] = {pos(rng), pos(rng), pos(rng),\n                     vel(rng), vel(rng), vel(rng), m(rng)};\n    }\n    return bodies;\n}\n\nstatic void WriteJson(const std::string &path, const std::string &payload) {\n    if (path.empty()) { std::cout << payload << std::endl; return; }\n    std::ofstream out(path.c_str(), std::ios::binary);\n    out << payload;\n}\n\nint main(int argc, char **argv) {\n    std::string json_path;\n    int seed = 42;\n    int num_bodies = 1024;\n    int rounds = 20;\n\n    for (int i = 1; i < argc; ++i) {\n        std::string arg = argv[i];\n        if (arg == \"--json\" && i + 1 < argc) json_path = argv[++i];\n        else if (arg == \"--seed\" && i + 1 < argc) seed = std::atoi(argv[++i]);\n        else if (arg == \"--bodies\" && i + 1 < argc) num_bodies = std::atoi(argv[++i]);\n        else if (arg == \"--rounds\" && i + 1 < argc) rounds = std::atoi(argv[++i]);\n    }\n\n    std::mt19937 rng(seed);\n    auto bodies = GenerateBodies(rng, num_bodies);\n\n    // Correctness check\n    std::vector<double> ref_fx, ref_fy, ref_fz;\n    std::vector<double> fx, fy, fz;\n    ReferenceForces(bodies, ref_fx, ref_fy, ref_fz);\n    ComputeForces(bodies, fx, fy, fz);\n    for (int i = 0; i < num_bodies; ++i) {\n        double mag = std::abs(ref_fx[i]) + std::abs(ref_fy[i]) + std::abs(ref_fz[i]);\n        double err = std::abs(fx[i] - ref_fx[i]) + std::abs(fy[i] - ref_fy[i])\n                   + std::abs(fz[i] - ref_fz[i]);\n        // Relative tolerance: allow FP reordering from SIMD/SoA/tiling\n        double tol = std::max(1e-6, mag * 1e-6);\n        if (err > tol) {\n            std::cerr << \"force mismatch at body \" << i\n                      << \" err=\" << err << \" tol=\" << tol << std::endl;\n            return 2;\n        }\n    }\n\n    // Benchmark\n    std::vector<double> latencies;\n    latencies.reserve(rounds);\n    double total_time = 0.0;\n\n    for (int r = 0; r < rounds; ++r) {\n        auto t0 = std::chrono::high_resolution_clock::now();\n        ComputeForces(bodies, fx, fy, fz);\n        auto t1 = std::chrono::high_resolution_clock::now();\n        double dt = std::chrono::duration<double>(t1 - t0).count();\n        latencies.push_back(dt);\n        total_time += dt;\n    }\n\n    double ops_per_sec = rounds / total_time;\n    std::sort(latencies.begin(), latencies.end());\n    double p99 = latencies.empty() ? 0.0\n        : latencies[(size_t)(0.99 * (latencies.size() - 1))];\n\n    std::ostringstream os;\n    os.setf(std::ios::fixed);\n    os.precision(6);\n    os << \"{\\\"ops_per_sec\\\":\" << ops_per_sec\n       << \",\\\"p99_latency_us\\\":\" << (p99 * 1e6)\n       << \",\\\"num_bodies\\\":\" << num_bodies << \"}\";\n    WriteJson(json_path, os.str());\n    return 0;\n}\n```"]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}